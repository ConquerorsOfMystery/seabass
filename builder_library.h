"\n"
"#guard cg_builder_library_DMHSW\n"
"\n"
"#include <stdmeta/reflect.hbas>\n"
"\n"
"/*\n"
"    THE BUILDER NAMESPACE\n"
"\n"
"    Parsehooks are sometimes used only for builders.\n"
"\n"
"    I want to have a special namespace system specifically for builder parsehooks\n"
"    which only work for codegen code.\n"
"*/\n"
"\n"
"\n"
"struct cg_builder_hook_namespace_entry\n"
"    noexport\n"
"    cgstr real //how is it REALLY invoked, the stuff after @?\n"
"    cgstr good //what is its fake name, the ?\n"
"end\n"
"\n"
"codegen cg_builder_hook_namespace_entry* builder_hook_namespace_entries = 0;\n"
"codegen uptr builder_hook_namespace_nentries = 0;\n"
"\n"
"\n"
"fn codegen builder_hook_namespace_add(cgstr real, cgstr fake):\n"
"    builder_hook_namespace_nentries++;\n"
"\n"
"\n"
"    //push onto the vector.\t\n"
"    builder_hook_namespace_entries = cast(cg_builder_hook_namespace_entry*)\n"
"    __builtin_realloc(\n"
"        cast(u8*)builder_hook_namespace_entries, \n"
"        sizeof(cg_builder_hook_namespace_entry) * builder_hook_namespace_nentries\n"
"    );\n"
"    \n"
"    //realloc never fails, remember?\n"
"    (builder_hook_namespace_entries + (builder_hook_namespace_nentries-1)).real:fromstr(real.s);\n"
"    (builder_hook_namespace_entries + (builder_hook_namespace_nentries-1)).good:fromstr(fake.s);\n"
"end\n"
"\n"
"fn codegen builder_hook_namespace_query(cgstr fake)->cgstr*:\n"
"    cgstr* retval\n"
"    cgstr* testme\n"
"    u64 i\n"
"\n"
"    //search the list\n"
"    for(i = 0, i < builder_hook_namespace_nentries, i++)\n"
"        testme = \n"
"        (\n"
"            builder_hook_namespace_entries + \n"
"            i\n"
"        ).good;\n"
"        retval = (\n"
"            builder_hook_namespace_entries + \n"
"            i\n"
"        ).real;\n"
"        if(fake.s streq testme.s)\n"
"            return retval;\n"
"        end\n"
"    end\n"
"    return cast(cgstr*)0;\n"
"end\n"
"\n"
"\n"
"//THE BUILDER\n"
"//makes new parsehooks which take in a token stream and return a token stream.\n"
"//it actually writes TWO codegen functions:\n"
"//one of them is the thing which is actually invoked.\n"
"\n"
"fn codegen parsehook_bldr():\n"
"    cgstrll* retval\n"
"    cgstrll* rwalk\n"
"    cgstr fname //the wrapper- which is what is invoked.\n"
"    cgstr fname2 //the thing you actually wrote, which returns to the wrapper.\n"
"    cgstr fname3 //the original version of the name..\n"
"    cgstrll* arglist //the code for the thing you actually wrote.\n"
"\n"
"    u64 linenum\n"
"    u64 colnum\n"
"    char* filename\n"
"\n"
"    if(cast(uptr)cg_peek() == 0)\n"
"        __builtin_puts(\"ERROR! bldr invoked at end of file.\");\n"
"        __builtin_exit(1);\n"
"    end\n"
"\n"
"    filename = cg_peek().filename;\n"
"    linenum = cg_peek().linenum;\n"
"    colnum = cg_peek().colnum;\n"
"    \n"
"    retval = cast(cgstrll*)0;\n"
"\n"
"    if(cast(uptr)cg_peek().text == 0)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"ERROR! bldr invoked on empty token.\");\n"
"        __builtin_puts(\"File:\");\n"
"        __builtin_puts(filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, linenum);\n"
"        __builtin_puts(buf);\n"
"        \n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    fname:fromstr(cg_peek().text);\n"
"    fname3:fromstr(cg_peek().text);\n"
"    __builtin_consume();\n"
"    if(1)\n"
"        cgstr f\n"
"        f:fromstr(\"parsehook_\");\n"
"        f:add(fname);\n"
"        fname:free();\n"
"        fname := f;\n"
"        fname2:fromstr(\"cg_inner_\");\n"
"        fname2:add(fname);\n"
"    end\n"
"    if(1)\n"
"        cgstr pre\n"
"        pre:fromstr(\"cg_bldr_\");\n"
"        //this is in the builder namespace.\n"
"        if(fname3:prefixed(pre) && (fname3.s strneq pre.s))\n"
"            //create builder namespace entry.\n"
"            cgstr fakename\n"
"            fakename:fromstr(fname3.s + 8);\n"
"            builder_hook_namespace_add(fname3, fakename);\n"
"            //__builtin_puts(\"Registered:\");\n"
"            //__builtin_puts(fakename.s);\n"
"            fakename:free();\n"
"        end \n"
"        pre:free();\n"
"        fname3:free();\n"
"    end\n"
"    //get the arglist.\n"
"    arglist = cg_token_grab_arglist(\"Invalid argument list passed to builder.\");\n"
"    //arglist:debug_print();\n"
"    //if this is a lone thing...\n"
"    if(arglist.d != CG_TOK_OBRACK)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"BLDR ERROR! No Arglist!\");\n"
"        __builtin_puts(\"File:\");\n"
"        __builtin_puts(filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, linenum);\n"
"        __builtin_puts(buf);\n"
"        \n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    \n"
"    //pop the brackets off.\n"
"    arglist = cg_tok_arglist_remove_brackets(arglist);\n"
"\n"
"    //define the initial function- the inner one.\n"
"\n"
"    retval = cg_qtok(\"fn\");\n"
"    rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\"codegen\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(fname2.s));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"->\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(arglist);\n"
"        //walk to the end.\n"
"        while(rwalk.right != cast(cgstrll*)0)\n"
"            rwalk = rwalk.right;\n"
"        end\n"
"    rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"\n"
"    //define the wrapper.\n"
"    rwalk:push_end(cg_qtok(\"fn\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"codegen\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(fname.s));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"\n"
"        \n"
"                \n"
"        //Some place to store the returned list.\n"
"        rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"        //fetch the inlist\n"
"        rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\t\t\n"
"        rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"\n"
"        //fetch the inlist\n"
"        //\n"
"        rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\t\t\n"
"        rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\t\t\n"
"\n"
"        //use the arglist grabber.\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"cast\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            \n"
"            rwalk:push_end(cg_qtok(\"cg_token_grab_arglist\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            if(1)\n"
"                cgstr qq;\n"
"                cgstr tt;\n"
"                qq:fromstr(\"\\\"ERROR! Builder \\\"\");\n"
"                    //parsehook_\n"
"                    tt.s = fname.s + 10; //skip parsehook_\n"
"                qq:add(tt);\n"
"                tt.s = \"\\\" has received an invalid arglist\\\"\";\n"
"                qq:add(tt);\n"
"                rwalk:push_end(cg_qtok(qq.s));rwalk = rwalk.right;\n"
"                qq:free();\n"
"            end\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        //end the assignment to inlist\n"
"        rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"        \n"
"        //remove brackets\n"
"        /*\n"
"            if(inlist.d == (cast(u8*)14))\n"
"                inlist = cg_tok_arglist_remove_brackets(inlist);\n"
"            end\n"
"        */\n"
"        \n"
"        rwalk:push_end(cg_qtok(\"if\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\".\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"d\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"==\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"cast\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                    rwalk:push_end(cg_qtok(\"u8\"));rwalk = rwalk.right;\n"
"                    rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"                    rwalk:push_end(cg_qtok(\"14\"));rwalk = rwalk.right; //the code for OBRACK.\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        \n"
"            rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"cg_tok_arglist_remove_brackets\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"            \n"
"        rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"        \n"
"        //call the inner function. Store the result in a variable- writeme\n"
"        rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(fname2.s));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"\n"
"        //free the inlist\n"
"        rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"freelist\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"\n"
"        //push writeme\n"
"        rwalk:push_end(cg_qtok(\"if\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"cast\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"uptr\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\t\t\n"
"            rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\t\t\n"
"        \n"
"            rwalk:push_end(cg_qtok(\"cgtok_push_stream\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"                    \n"
"        rwalk:push_end(cg_qtok(\"else\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"__builtin_puts\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                //make something creative.\n"
"                if(1)\n"
"                    cgstr qq;\n"
"                    cgstr tt;\n"
"                    qq:fromstr(\"\\\"ERROR! Builder \\\"\");\n"
"                        //parsehook_\n"
"                        tt.s = fname.s + 10; //skip parsehook_\n"
"                    qq:add(tt);\n"
"                    tt.s = \"\\\" has returned an invalid arglist, it cannot be pushed onto the token stream\\\"\";\n"
"                    qq:add(tt);\n"
"                    rwalk:push_end(cg_qtok(qq.s));rwalk = rwalk.right;\n"
"                    qq:free();\n"
"                end\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"    fname:free();\n"
"    fname2:free();\n"
"    \n"
"    cgtok_push_stream(retval);\n"
"end\n"
"\n"
"\n"
"fn codegen parsehook_bldrn():\n"
"    cgstrll* retval\n"
"    cgstrll* rwalk\n"
"    cgstr fname //the wrapper- which is what is invoked.\n"
"    cgstr fname2 //the thing you actually wrote, which returns to the wrapper.\n"
"    cgstr fname3 //the original version of the name..\n"
"    cgstrll* arglist //the code for the thing you actually wrote.\n"
"\n"
"    u64 linenum\n"
"    u64 colnum\n"
"    u64 nargs\n"
"    char* filename\n"
"\n"
"    if(cast(uptr)cg_peek() == 0)\n"
"        __builtin_puts(\"ERROR! bldr invoked at end of file.\");\n"
"        __builtin_exit(1);\n"
"    end\n"
"\n"
"    filename = cg_peek().filename;\n"
"    linenum = cg_peek().linenum;\n"
"    colnum = cg_peek().colnum;\n"
"    \n"
"    retval = cast(cgstrll*)0;\n"
"\n"
"    if(cast(uptr)cg_peek().text == 0)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"ERROR! bldr invoked on empty token.\");\n"
"        __builtin_puts(\"File:\");\n"
"        __builtin_puts(filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, linenum);\n"
"        __builtin_puts(buf);\n"
"        \n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    fname:fromstr(cg_peek().text);\n"
"    fname3:fromstr(cg_peek().text);\n"
"    __builtin_consume();\n"
"    if(1)\n"
"        cgstr f\n"
"        f:fromstr(\"parsehook_\");\n"
"        f:add(fname);\n"
"        fname:free();\n"
"        fname := f;\n"
"        fname2:fromstr(\"cg_inner_\");\n"
"        fname2:add(fname);\n"
"    end\n"
"    if(1)\n"
"        cgstr pre\n"
"        pre:fromstr(\"cg_bldr_\");\n"
"        //this is in the builder namespace.\n"
"        if(fname3:prefixed(pre) && (fname3.s strneq pre.s))\n"
"            //create builder namespace entry.\n"
"            cgstr fakename\n"
"            fakename:fromstr(fname3.s + 8);\n"
"            builder_hook_namespace_add(fname3, fakename);\n"
"            //__builtin_puts(\"Registered:\");\n"
"            //__builtin_puts(fakename.s);\n"
"            fakename:free();\n"
"        end \n"
"        pre:free();\n"
"        fname3:free();\n"
"    end\n"
"    if(cg_peek().d != CG_TOK_INT_CONST)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"BLDRN ERROR! No nargs!\");\n"
"        __builtin_puts(\"Syntax is @bldrn myBldr_with_3_args 3 [code();]\");\n"
"        __builtin_puts(\"File:\");\n"
"        __builtin_puts(filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, linenum);\n"
"        __builtin_puts(buf);\n"
"        \n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    \n"
"    nargs = __builtin_atoi(cg_peek().text);\n"
"    __builtin_consume(); //eat it.\n"
"    //get the arglist.\n"
"    arglist = cg_token_grab_arglist(\"Invalid argument list passed to builder.\");\n"
"\n"
"    //if this is a lone thing...\n"
"    if(arglist.d != CG_TOK_OBRACK)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"BLDR ERROR! No Arglist!\");\n"
"        __builtin_puts(\"File:\");\n"
"        __builtin_puts(filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, linenum);\n"
"        __builtin_puts(buf);\n"
"        \n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    \n"
"    //pop the brackets off.\n"
"    arglist = cg_tok_arglist_remove_brackets(arglist);\n"
"\n"
"    //define the initial function- the inner one.\n"
"\n"
"    retval = cg_qtok(\"fn\");\n"
"    rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\"codegen\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(fname2.s));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"    if(nargs > 0)\n"
"        rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"    end\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"->\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(arglist);\n"
"        //walk to the end.\n"
"        for(0, rwalk.right != cast(cgstrll*)0, rwalk = rwalk.right)\n"
"            ;\n"
"        end\n"
"    rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"\n"
"    //define the wrapper.\n"
"    rwalk:push_end(cg_qtok(\"fn\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"codegen\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(fname.s));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"\n"
"        \n"
"                \n"
"        //Some place to store the returned list.\n"
"        rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"        \n"
"        if(nargs > 0)\n"
"            rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"            if(nargs > 1)\n"
"                rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"inlist2\"));rwalk = rwalk.right;\t\t\n"
"            end\n"
"        end\n"
"        //fetch the inlist\n"
"        //\n"
"        if(nargs > 0)\n"
"            rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\t\t\n"
"            rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\t\t\n"
"\n"
"            //use the arglist grabber.\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"cast\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                    rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"                    rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"                \n"
"                rwalk:push_end(cg_qtok(\"cg_token_grab_arglist\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                if(1)\n"
"                    cgstr qq;\n"
"                    cgstr tt;\n"
"                    qq:fromstr(\"\\\"ERROR! Builder \\\"\");\n"
"                        //parsehook_\n"
"                        tt.s = fname.s + 10; //skip parsehook_\n"
"                    qq:add(tt);\n"
"                    tt.s = \"\\\" has received an invalid arglist\\\"\";\n"
"                    qq:add(tt);\n"
"                    rwalk:push_end(cg_qtok(qq.s));rwalk = rwalk.right;\n"
"                    qq:free();\n"
"                end\n"
"                rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            //end the assignment to inlist\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"            i64 nargs_left\n"
"            nargs_left = nargs-1;\n"
"            for(0, nargs_left, nargs_left--)\n"
"                //grab an additional argument.\n"
"                      //fetch the inlist\n"
"                      rwalk:push_end(cg_qtok(\"inlist2\"));rwalk = rwalk.right;\t\t\n"
"                      rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\t\t\n"
"\n"
"                      //use the arglist grabber.\n"
"                      rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                          rwalk:push_end(cg_qtok(\"cast\"));rwalk = rwalk.right;\n"
"                          rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                              rwalk:push_end(cg_qtok(\"cgstrll\"));rwalk = rwalk.right;\n"
"                              rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"                          rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"\n"
"                          rwalk:push_end(cg_qtok(\"cg_token_grab_arglist\"));rwalk = rwalk.right;\n"
"                          rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                          if(1)\n"
"                              cgstr qq;\n"
"                              cgstr tt;\n"
"                              qq:fromstr(\"\\\"ERROR! Buildern \\\"\");\n"
"                              //parsehook_\n"
"                              tt.s = fname.s + 10; //skip parsehook_\n"
"                              qq:add(tt);\n"
"                              tt.s = \"\\\" has received an invalid arglist\\\"\";\n"
"                              qq:add(tt);\n"
"                              rwalk:push_end(cg_qtok(qq.s));rwalk = rwalk.right;\n"
"                              qq:free();\n"
"                          end\n"
"                          rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"                      //end the assignment to inlist2\n"
"                      rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"                      //push inlist2 onto inlist.\n"
"                      rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\"push_end\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\"inlist2\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"                      rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"            end\n"
"\n"
"        end\n"
"\n"
"        //call the inner function. Store the result in a variable- writeme\n"
"        rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(fname2.s));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"        if(nargs > 0)\n"
"            rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"        end\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"\n"
"        //free the inlist\n"
"        if(nargs > 0)\n"
"            rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"freelist\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"        end\n"
"        //push writeme\n"
"        rwalk:push_end(cg_qtok(\"if\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"cast\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"uptr\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\t\t\n"
"            rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\t\t\n"
"        \n"
"            rwalk:push_end(cg_qtok(\"cgtok_push_stream\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                rwalk:push_end(cg_qtok(\"writeme\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"                    \n"
"        rwalk:push_end(cg_qtok(\"else\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"__builtin_puts\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"                //make something creative.\n"
"                if(1)\n"
"                    cgstr qq;\n"
"                    cgstr tt;\n"
"                    qq:fromstr(\"\\\"ERROR! Builder \\\"\");\n"
"                        //parsehook_\n"
"                        tt.s = fname.s + 10; //skip parsehook_\n"
"                    qq:add(tt);\n"
"                    tt.s = \"\\\" has returned an invalid arglist, it cannot be pushed onto the token stream\\\"\";\n"
"                    qq:add(tt);\n"
"                    rwalk:push_end(cg_qtok(qq.s));rwalk = rwalk.right;\n"
"                    qq:free();\n"
"                end\n"
"            rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"            rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"        rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"end\"));rwalk = rwalk.right;\n"
"    fname:free();\n"
"    fname2:free();\n"
"    \n"
"    cgtok_push_stream(retval);\n"
"end\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"/*\n"
"    Builder namespace wrapper.\n"
"\n"
"    used exactly like builder, but automatically detects\n"
"    usage of stuff in the builder parsehook namespace.\n"
"*/\n"
"\n"
"@bldr mkbldr [\n"
"    cgstrll* retval\n"
"    cgstrll* inlist_dupe\n"
"    cgstrll* following\n"
"    cgstrll* walker\n"
"\n"
"    inlist_dupe = inlist:dupell();\n"
"    following = inlist_dupe.right;\n"
"    inlist_dupe.right = cast(cgstrll*)0;\n"
"\n"
"    if( following == 0)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"MKBUILDER_ERROR\");\n"
"        __builtin_puts(\"Invoked mkbldr with null body.\");\n"
"        __builtin_puts(\"Filename:\");\n"
"        __builtin_puts(following.filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, following.linenum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, following.colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"\n"
"    for(walker = following, 1, walker = walker.right)\n"
"        //we definitely won't find anything if we're null, or our right\n"
"        if( walker == 0) break end\n"
"        if(walker.right == 0) break end\n"
"        //we definitely won't find anything if our text or our right's text is null.\n"
"        if( walker.text == 0) continue end\n"
"        if( walker.right.text == 0) continue end\n"
"        if(\n"
"            (walker.d == CG_TOK_OPERATOR) && (walker.text streq \"@\")\n"
"        )\n"
"            //check if we have one!\n"
"            cgstr* m\n"
"            cgstr f\n"
"            f.s = walker.right.text;\n"
"            m = builder_hook_namespace_query(f);\n"
"            if(m != 0)\n"
"                //do the replacement.\n"
"                f:free();\n"
"                walker.right.text = __builtin_strdup(m.s);\n"
"            end\n"
"        end\n"
"    end\n"
"    \n"
"\n"
"    retval =  (cg_qtok(\"@\"));\n"
"    retval:push_end(cg_qtok(\"bldr\"));\n"
"    retval:push_end(inlist_dupe);\n"
"    retval:push_end(cg_qtok(\"[\"));\n"
"    retval:push_end(following);\n"
"    retval:push_end(cg_qtok(\"]\"));\n"
"    return retval;\n"
"]\n"
"\n"
"//TODO: mkbldrn\n"
"\n"
"\n"
"//mkbldrn\n"
"//actually somewhat simpler than mkbldr\n"
"//it takes a number of arguments expected\n"
"@bldrn mkbldrn 3 [\n"
"    cgstrll* retval\n"
"    cgstrll* inlist_dupe\n"
"    cgstrll* following\n"
"    cgstrll* walker\n"
"    \n"
"    cgstr name\n"
"    \n"
"\n"
"    inlist_dupe = inlist:dupell();\n"
"    following = inlist_dupe.right;\n"
"\n"
"    //@cg_bldr_ifnull [following]\n"
"    if(following == 0)\n"
"        char[500] buf;\n"
"        __builtin_puts(\"MKBUILDER_ERROR\");\n"
"        __builtin_puts(\"Invoked mkbldrn with null where the number of args should be\");\n"
"        __builtin_puts(\"Filename:\");\n"
"        __builtin_puts(following.filename);\n"
"        __builtin_puts(\"Linenum:\");\n"
"        __builtin_utoa(buf, following.linenum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_puts(\"Colnum:\");\n"
"        __builtin_utoa(buf, following.colnum);\n"
"        __builtin_puts(buf);\n"
"        __builtin_exit(1);\n"
"    end\n"
"\n"
"    for(walker = following, 1, walker = walker.right)\n"
"        //we definitely won't find anything if we're null, or our right\n"
"        //@cg_bldr_ifnull [walker] break end\n"
"        //@cg_bldr_ifnull [walker.right] break end\n"
"        if(walker == 0) break end\n"
"        if(walker.right == 0) break end\n"
"        //we definitely won't find anything if our text or our right's text is null.\n"
"        //@cg_bldr_ifnull [walker.text] continue end\n"
"        //@cg_bldr_ifnull [walker.right.text] continue end\n"
"        if(walker.text == 0) continue end\n"
"        if(walker.right.text == 0) continue end\n"
"        if(\n"
"            (walker.d == CG_TOK_OPERATOR) && (walker.text streq \"@\")\n"
"        )\n"
"            //check if we have one!\n"
"            cgstr* m\n"
"            cgstr f\n"
"            f.s = walker.right.text;\n"
"            m = builder_hook_namespace_query(f);\n"
"            //@cg_bldr_ifnotnull [m]\n"
"            if(m != 0)\n"
"                //do the replacement.\n"
"                f:free();\n"
"                walker.right.text = __builtin_strdup(m.s);\n"
"            end\n"
"        end\n"
"    end\n"
"    \n"
"\n"
"    retval =  (cg_qtok(\"@\")); walker = retval;\n"
"    retval:push_end(cg_qtok(\"bldrn\")); walker = walker.right;\n"
"    retval:push_end(inlist_dupe);\n"
"    return retval;\n"
"]\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"@bldrn cg_bldr_dupell_inlist 0 [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        \n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    cgstrll* retval\n"
"    cgstrll* inlist_dupe\n"
"    cgstrll* rwalk\n"
"\n"
"    retval = cg_qtok(\"cgstrll\");rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"inlist_dupe\"));rwalk = rwalk.right;\n"
"\n"
"    rwalk:push_end(cg_qtok(\"inlist_dupe\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"dupell\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\")  );rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\";\"));\n"
"    return retval;\n"
"]\n"
"\n"
"        \n"
"@bldrn cg_bldr_dupe_inlist 0 [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    cgstrll* retval\n"
"    cgstrll* inlist_dupe\n"
"    cgstrll* rwalk\n"
"\n"
"\n"
"    retval = cg_qtok(\"cgstrll\");rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\"*\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"inlist_dupe\"));rwalk = rwalk.right;\n"
"\n"
"    rwalk:push_end(cg_qtok(\"inlist_dupe\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"inlist\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"dupe\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\")  );rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\";\"));\n"
"    return retval;\n"
"]\n"
"\n"
"//Tools for making builders..\n"
"//TOOL 1: THE QTOK PUSHER\n"
"//one of the most often used functions in the entire mp library...\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_pushqtok\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    cgstrll* retval\n"
"    cgstrll* rwalk\n"
"    \n"
"    retval =       cg_qtok(\"rwalk\");rwalk = retval;\n"
"    //rwalk:push_end(cg_qtok(\":\"));rwalk = rwalk.right;\n"
"    //rwalk:push_end(cg_qtok(\"push_end\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\".\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"right\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"    \n"
"    //rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"    \n"
"    rwalk:push_end(cg_qtok(\"cg_qtok\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"(\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(inlist:dupell());rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    \n"
"    //rwalk:push_end(cg_qtok(\")\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"    \n"
"    rwalk:push_end(cg_qtok(\"rwalk\"));rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\"=\"));rwalk = rwalk.right;\n"
"    rwalk:push_end(cg_qtok(\"rwalk\"));rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\".\"));rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\"right\"));rwalk = retval;\n"
"    rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"    //retval:debug_print();\n"
"    return retval;\n"
"]\n"
"\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_initqtok\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @dupell_inlist ;\n"
"    \n"
"    //automate this line.\n"
"    cgstrll* retval\n"
"    cgstrll* rwalk\n"
"    retval = cg_qtok(\"cgstrll\");rwalk = retval;\n"
"    \n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"retval\"\n"
"    \n"
"    @pushqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"rwalk\"\n"
"    \n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"cg_qtok\"\n"
"    @pushqtok \"(\"\n"
"    rwalk:push_end(inlist_dupe);\n"
"    while(rwalk.right != 0)\n"
"        rwalk = rwalk.right\n"
"    end\n"
"    @pushqtok \")\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \";\"\n"
"    return retval;\n"
"]\n"
"\n"
"//same as above, but no variable declarations.\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_initqtok_nodecl\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    \n"
"    @initqtok \"retval\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"cg_qtok\"\n"
"    @pushqtok \"(\"\n"
"    rwalk:push_end(inlist:dupe());\n"
"    while(rwalk.right != 0)\n"
"        rwalk = rwalk.right\n"
"    end\n"
"    @pushqtok \")\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \";\"\n"
"    return retval;\n"
"]\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_initvars\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @initqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"retval\"\n"
"    \n"
"    @pushqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"rwalk\"\n"
"    return retval;\n"
"]\n"
"\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_initvars_dummy\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @initqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"retval\"\n"
"    \n"
"    @pushqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \"@\"\n"
"    @pushqtok \"cg_bldr_initqtok\"\n"
"    @pushqtok \"\\\"#\\\"\"\n"
"    return retval;\n"
"]\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_initvars_dummy_var\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @initqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"retval\"\n"
"    \n"
"    @pushqtok \"cgstrll\"\n"
"    @pushqtok \"dummy\"\n"
"    \n"
"    @pushqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"rwalk\"\n"
"    \n"
"    @pushqtok \"dummy\"\n"
"    @pushqtok \".\"\n"
"    @pushqtok \"text\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"\\\"#\\\"\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"dummy\"\n"
"    @pushqtok \".\"\n"
"    @pushqtok \"d\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"\\\"0\\\"\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"dummy\"\n"
"    @pushqtok \";\"\n"
"    return retval;\n"
"]\n"
"\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_inittok\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @dupell_inlist ;\n"
"    @initqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"retval\"\n"
"    \n"
"    @pushqtok \"cgstrll\"\n"
"    @pushqtok \"*\"\n"
"    @pushqtok \"rwalk\"\n"
"    \n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \"=\"\n"
"    //not qtok!\n"
"    //@pushqtok \"cg_qtok\"\n"
"    @pushqtok \"(\"\n"
"    rwalk.right = (inlist_dupe);\n"
"    while(rwalk.right != 0)\n"
"        rwalk = rwalk.right\n"
"    end\n"
"    @pushqtok \")\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \";\"\n"
"    return retval;\n"
"]\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_inittok_nodecl\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @dupell_inlist ;\n"
"    \n"
"    @initqtok \"retval\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"cg_qtok\"\n"
"    @pushqtok \"(\"\n"
"    rwalk:push_end(inlist_dupe);\n"
"    while(rwalk.right != 0)\n"
"        rwalk = rwalk.right\n"
"    end\n"
"    @pushqtok \")\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"retval\"\n"
"    @pushqtok \";\"\n"
"    return retval;\n"
"]\n"
"\n"
"\n"
"//rwalk:push_end(cg_qtok(\";\"));rwalk = rwalk.right;\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"        cg_bldr_pushtok\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"\n"
"    @initqtok \"rwalk\"\n"
"    @pushqtok \".\"\n"
"    @pushqtok \"right\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"(\"\n"
"        rwalk:push_end(inlist:dupell());\n"
"        while(rwalk.right != 0)\n"
"            rwalk = rwalk.right\n"
"        end\n"
"    @pushqtok \")\"\n"
"    @pushqtok \";\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \"=\"\n"
"    @pushqtok \"rwalk\"\n"
"    @pushqtok \".\"\n"
"    @pushqtok \"right\"\n"
"    @pushqtok \";\"\n"
"    \n"
"    return retval;\n"
"]\n"
"\n"
"@mkbldr [\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    cg_bldr_rwalk_skip\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    @initqtok \"while\"\n"
"    @pushqtok \"(\"\n"
"        @pushqtok \"rwalk\"\n"
"        @pushqtok \".\"\n"
"        @pushqtok \"right\"\n"
"        @pushqtok \"!=\"\n"
"        @pushqtok \"cast\"\n"
"        @pushqtok \"(\"\n"
"            @pushqtok \"cgstrll\"\n"
"            @pushqtok \"*\"\n"
"        @pushqtok \")\"\n"
"        @pushqtok \"0\"\n"
"    @pushqtok \")\"\n"
"        @pushqtok \"rwalk\"\n"
"        @pushqtok \"=\"\n"
"        @pushqtok \"rwalk\"\n"
"        @pushqtok \".\"\n"
"        @pushqtok \"right\"\n"
"        @pushqtok \";\"\n"
"    @pushqtok \"end\"\n"
"    return retval;\n"
"]\n"
"\n"
""
