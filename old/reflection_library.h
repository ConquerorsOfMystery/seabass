"\n"
"\n"
"#guard CompileTimeASTManip_DMHSW\n"
"\n"
"#define CG_MAX_FARGS 64\n"
"\n"
"codegen u8* CG_TOK_SPACE       =0;\n"
"codegen u8* CG_TOK_NEWLINE     =1;\n"
"codegen u8* CG_TOK_STRING      =2;\n"
"codegen u8* CG_TOK_CHARLIT     =3;\n"
"codegen u8* CG_TOK_COMMENT     =4;\n"
"codegen u8* CG_TOK_MACRO       =5;\n"
"codegen u8* CG_TOK_INT_CONST   =6;\n"
"codegen u8* CG_TOK_FLOAT_CONST =7;\n"
"codegen u8* CG_TOK_IDENT    =8;\n"
"codegen u8* CG_TOK_OPERATOR =9;\n"
"codegen u8* CG_TOK_OCB    =10;\n"
"codegen u8* CG_TOK_CCB    =11;\n"
"codegen u8* CG_TOK_OPAREN =12;\n"
"codegen u8* CG_TOK_CPAREN =13;\n"
"codegen u8* CG_TOK_OBRACK =14;\n"
"codegen u8* CG_TOK_CBRACK =15;\n"
"codegen u8* CG_TOK_SEMIC =16;\n"
"codegen u8* CG_TOK_UNKNOWN =17;\n"
"codegen u8* CG_TOK_KEYWORD =18;\n"
"codegen u8* CG_TOK_ESC_NEWLINE =19;\n"
"codegen u8* CG_TOK_COMMA =20;\n"
"codegen u8* CG_TOK_MACRO_OP = 21;\n"
"codegen u8* CG_TOK_INCSYS = 22;\n"
"codegen u8* CG_TOK_INCLUDE = 23;\n"
"codegen u8* CG_TOK_DEFINE = 24;\n"
"codegen u8* CG_TOK_UNDEF = 25;\n"
"codegen u8* CG_TOK_GUARD = 26;\n"
"\n"
"codegen int CG_BASE_VOID=0;\n"
"codegen int CG_BASE_U8=1;\n"
"codegen int CG_BASE_I8=2;\n"
"codegen int CG_BASE_U16=3;\n"
"codegen int CG_BASE_I16=4;\n"
"codegen int CG_BASE_U32=5;\n"
"codegen int CG_BASE_I32=6;\n"
"codegen int CG_BASE_U64=7;\n"
"codegen int CG_BASE_I64=8;\n"
"codegen int CG_BASE_F32=9;\n"
"codegen int CG_BASE_F64=10;\n"
"codegen int CG_BASE_STRUCT=11;\n"
"codegen int CG_BASE_FUNCTION=12;\n"
"codegen int CG_NBASETYPES=13;\n"
"\n"
"codegen int\tCG_EXPR_BAD=0;\n"
"codegen int CG_EXPR_BUILTIN_CALL=1; \n"
"codegen int CG_EXPR_FCALL=2; \n"
"codegen int CG_EXPR_SIZEOF=3; \n"
"codegen int CG_EXPR_INTLIT=4; \n"
"codegen int CG_EXPR_FLOATLIT=5; \n"
"codegen int CG_EXPR_STRINGLIT=6;  \n"
"codegen int CG_EXPR_LSYM=7; \n"
"codegen int CG_EXPR_GSYM=8; \n"
"codegen int CG_EXPR_SYM=9; \n"
"codegen int CG_EXPR_POST_INCR=10;\n"
"codegen int CG_EXPR_POST_DECR=11; \n"
"codegen int CG_EXPR_INDEX=12; \n"
"codegen int CG_EXPR_MEMBER=13; \n"
"codegen int CG_EXPR_METHOD=14; \n"
"codegen int CG_EXPR_CAST=15; \n"
"codegen int CG_EXPR_NEG=16; \n"
"codegen int CG_EXPR_COMPL=17; \n"
"codegen int CG_EXPR_NOT=18; \n"
"codegen int CG_EXPR_PRE_INCR=19; \n"
"codegen int CG_EXPR_PRE_DECR=20; \n"
"codegen int CG_EXPR_MUL=21; \n"
"codegen int CG_EXPR_DIV=22; \n"
"codegen int CG_EXPR_MOD=23; \n"
"codegen int CG_EXPR_ADD=24; \n"
"codegen int CG_EXPR_SUB=25; \n"
"codegen int CG_EXPR_BITOR=26; \n"
"codegen int CG_EXPR_BITAND=27; \n"
"codegen int CG_EXPR_BITXOR=28; \n"
"codegen int CG_EXPR_LSH=29; \n"
"codegen int CG_EXPR_RSH=30; \n"
"codegen int CG_EXPR_LOGOR=31; \n"
"codegen int CG_EXPR_LOGAND=32; \n"
"codegen int CG_EXPR_LT=33; \n"
"codegen int CG_EXPR_GT=34; \n"
"codegen int CG_EXPR_LTE=35; \n"
"codegen int CG_EXPR_GTE=36; \n"
"codegen int CG_EXPR_EQ=37; \n"
"codegen int CG_EXPR_NEQ=38; \n"
"codegen int CG_EXPR_ASSIGN=39; \n"
"codegen int CG_EXPR_MOVE=40; \n"
"codegen int CG_EXPR_CONSTEXPR_FLOAT=41; \n"
"codegen int CG_EXPR_CONSTEXPR_INT=42; \n"
"codegen int CG_EXPR_STREQ=43; \n"
"codegen int CG_EXPR_STRNEQ=44; \n"
"codegen int CG_EXPR_MEMBERPTR=45; \n"
"codegen int CG_EXPR_GETFNPTR=46; \n"
"codegen int CG_EXPR_CALLFNPTR=47; \n"
"codegen int CG_EXPR_GETGLOBALPTR=48; \n"
"codegen int CG_NEXPR_TYPES=49;\n"
"\n"
"codegen int CG_STMT_BAD=0;\n"
"codegen int CG_STMT_NOP=1;\n"
"codegen int CG_STMT_EXPR=2;\n"
"codegen int CG_STMT_LABEL=3;\n"
"codegen int CG_STMT_GOTO=4;\n"
"codegen int CG_STMT_WHILE=5;\n"
"codegen int CG_STMT_FOR=6;\n"
"codegen int CG_STMT_IF=7;\n"
"codegen int CG_STMT_ELIF=8;\n"
"codegen int CG_STMT_ELSE=9;\n"
"codegen int CG_STMT_RETURN=10;\n"
"codegen int CG_STMT_TAIL=11;\n"
"codegen int CG_STMT_ASM=12;\n"
"codegen int CG_STMT_CONTINUE=13;\n"
"codegen int CG_STMT_BREAK=14;\n"
"codegen int CG_STMT_SWITCH=15;\n"
"codegen int CG_NSTMT_TYPES;\n"
"\n"
"\n"
"\n"
"/*\n"
"    String library code for compiletime cbas code.\n"
"*/\n"
"\n"
"class cgstr\n"
"    noexport\n"
"    char* s\n"
"end\n"
"\n"
"fn codegen cgstrcpy(char* s, char* s1):\n"
"    while(1)\n"
"        s[0] = s1[0];\n"
"        if(s1[0] == 0) return; end\n"
"        s++;s1++;\n"
"    end\n"
"end\n"
"\n"
"fn codegen cgisdigit(char c)->u8:\n"
"    if(c >= '0' && c <= '9') return 1; end\n"
"    return 0;\n"
"end\n"
"\n"
"fn codegen cgisalpha(char c)->u8:\n"
"    if(c >= 'a' && c <= 'z') return 1; end\n"
"    if(c >= 'A' && c <= 'Z') return 1; end\n"
"    return 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:isempty()->u8:\n"
"    if(this.s == cast(char*)0)\n"
"        return 1; \n"
"    end\n"
"    if(this.s[0] == 0)\n"
"        return 1;\n"
"    end\n"
"    return 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:isnull->u8:\n"
"    if(this.s == cast(char*)0)\n"
"        return 1; \n"
"    end\n"
"    return 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:len->u64:\n"
"    u64 i\n"
"    i = 0;\n"
"\n"
"    //necessary to prevent segfaults\n"
"    if(this:isempty())\n"
"        return 0; \n"
"    end\n"
"\n"
"    //count characters\n"
"    for(i=0, this.s[i], i++) end\n"
"    \n"
"    return i;\n"
"end\n"
"\n"
"\n"
"\n"
"method codegen cgstr:print:\n"
"    __builtin_puts(this.s);\n"
"end\n"
"\n"
"method codegen cgstr:start:\n"
"    this.s = cast(char*)0;\n"
"end\n"
"\n"
"\n"
"\n"
"method codegen cgstr:free:\n"
"    __builtin_free(this.s);\n"
"    this.s = cast(char*)0;\n"
"end\n"
"\n"
"method codegen pure cgstr:prefixed(cgstr o)->u8: //is THIS prefixed by o?\n"
"    int i\n"
"    if(o:isempty()) return 1; end //yes, we are prefixed by the null string.\n"
"    \n"
"    if(this:isempty()) return 0; end //we are not prefixed by a non-empty string because we are empty.\n"
"    \n"
"    for(i = 0,o.s[i] neq 0,i++)\n"
"        if(this.s[i] neq o.s[i]) //notice that this actually handles this.s[i] == 0....\n"
"            return 0;\n"
"        end\n"
"    end\n"
"    \n"
"    //we are prefixed by this string because we reached the end of it!\n"
"    return 1;\n"
"end\n"
"\n"
"method codegen pure cgstr:postfixed(cgstr o)->u8: //is THIS postfixed by o?\n"
"    sqword i\n"
"    cgstr h\n"
"    sqword tlen //I'm doing this over and over again... Note to self: automate the process of creating tlen and olen...\n"
"    sqword olen\n"
"    \n"
"    if(o:isempty()) return 1; end //yes, we are postfixed by the null string.\n"
"    if(this:isempty()) return 0; end //we are not postfixed by a non-empty string because we are empty.\n"
"    tlen = this:len();\n"
"    olen = o:len();\n"
"    if(tlen < olen) return 0; end //we cannot be postfixed if we are shorter...\n"
"    h.s = this.s + (tlen - olen); //skip the first part of the string\n"
"\n"
"    return h:prefixed(o);\n"
"end\n"
"\n"
"method codegen cgstr:invert:\n"
"    uqword e;\n"
"    uqword i;\n"
"    i = 0;\n"
"    e = this:len()-1;\n"
"    for(0, i < e, i++ | e--)\n"
"        char f\n"
"        f = this.s[i];\n"
"        this.s[i] = this.s[e];\n"
"        this.s[e] = f;\n"
"    end\n"
"end\n"
"\n"
"fn codegen pure cgislower(char a)->u8:\n"
"    if(a <= 'z')\n"
"        if(a >= 'a')\n"
"            return 1;\n"
"        end\n"
"    end\n"
"    return 0;\n"
"end\n"
"\n"
"fn codegen pure cgisupper(char a)->u8:\n"
"    if(a <= 'Z')\n"
"        if(a >= 'A')\n"
"            return 1;\n"
"        end\n"
"    end\n"
"    return 0;\n"
"end\n"
"\n"
"fn codegen pure cgtoupper(char a)->char:\n"
"    u8 diff1\n"
"    u8 diff2\n"
"    u8 isl\n"
"    isl = cgislower(a);\n"
"    diff1 = isl * 'a';\n"
"    diff2 = isl * 'A';\n"
"    a = a - diff1;\n"
"    a = a + diff2;\n"
"    return a;\n"
"end\n"
"\n"
"fn codegen pure cgtolower(char a)->char:\n"
"    u8 diff1\n"
"    u8 diff2\n"
"    u8 ish\n"
"    ish = cgisupper(a);\n"
"    diff1 = ish * 'A';\n"
"    diff2 = ish * 'a';\n"
"    a = a - diff1;\n"
"    a = a + diff2;\n"
"    return a;\n"
"end\n"
"\n"
"\n"
"method codegen cgstr:transform(char* input_fun):\n"
"    uqword i\n"
"    uqword tlen\n"
"    tlen = this:len();\n"
"    for(i = 0, i < tlen, i++)\n"
"        this.s[i] = callfnptr[cgtoupper](input_fun)(this.s[i]);\n"
"    end\n"
"    return;\n"
"end\n"
"\n"
"method codegen cgstr:toupper():\n"
"    uqword i\n"
"    uqword tlen\n"
"    tlen = this:len();\n"
"    for(i = 0, i < tlen, i++)\n"
"        this.s[i] = cgtoupper(this.s[i]);\n"
"    end\n"
"end\n"
"\n"
"method codegen cgstr:tolower():\n"
"    uqword i\n"
"    uqword tlen\n"
"    tlen = this:len();\n"
"    for(i = 0, i < tlen, i++)\n"
"        this.s[i] = cgtolower(this.s[i]);\n"
"    end\n"
"end\n"
"\n"
"method codegen pure cgstr:compare(cgstr o)->i16: //- for lt, 0 for eq, + for gt\n"
"    uqword i\n"
"    uqword tlen\n"
"    uqword olen\n"
"    tlen = this:len();\n"
"    olen = o:len();\n"
"    if(this.s == o.s) return 0; end//they are the same string. Conveniently, this also tests for the null case.\n"
"    \n"
"    for(i = 0, 1, i++)\n"
"        if(this.s[i] == 0)\n"
"            if(o.s[i] == 0)\n"
"                return 0;;; //equals!\n"
"            end\n"
"        end\n"
"        if(this.s[i] != o.s[i])\n"
"            return cast(i16)(cast(u16)this.s[i] - cast(u16)o.s[i]);\n"
"        end\n"
"    end\n"
"\n"
"    return 0;\n"
"end\n"
"\n"
"method codegen pure cgstr:find(cgstr o)->i64:\n"
"    u64 tlen \n"
"    u64 olen\n"
"    u64 i\n"
"\n"
"    if(o:isempty()) return 0; end     //we can find the empty string in ourselves.\n"
"    if(this:isempty()) return -1; end //we cannot find anything in ourselves because we are empty.\n"
"\n"
"    tlen = this:len(); olen = o:len();\n"
"    if(olen > tlen) return -1; end    //we cannot find a longer string than ourselves in ourself.\n"
"\n"
"\n"
"    for(i = 0, tlen >= olen, i++ | tlen--)\n"
"        cgstr q\n"
"        q.s = this.s + i;\n"
"        if(q:prefixed(o))\n"
"            return i;\n"
"        end\n"
"    end\n"
"\n"
"    //cannot find it!\n"
"    return -1;\n"
"end\n"
"\n"
"method codegen cgstr:add(cgstr* o):\n"
"    \n"
"    char* s_new\n"
"    u64 tlen\n"
"    u64 olen\n"
"    tlen = this:len();\n"
"    olen = o:len();\n"
"\n"
"    /*\n"
"        __builtin_puts(\"I am:\");\n"
"        __builtin_puts(this.s);\n"
"        __builtin_puts(\"o is:\");\n"
"        __builtin_puts(o.s);\n"
"        __builtin_puts(\"______________\");\n"
"    */\n"
"    \n"
"    s_new = __builtin_malloc(tlen + olen + 1);\n"
"    \n"
"    if(tlen)\n"
"        __builtin_memcpy(s_new, this.s, tlen);\n"
"    end\n"
"    if(olen)\n"
"        __builtin_memcpy(s_new + tlen, o.s, olen);\n"
"    end\n"
"    \n"
"    s_new[tlen+olen] = 0;\n"
"    this:free();\n"
"    this.s = s_new;\n"
"end\n"
"\n"
"method codegen cgstr:addstr(char* s):\n"
"    cgstr o\n"
"    o.s = s;\n"
"    this:add(o);\n"
"end\n"
"method codegen cgstr:addeatstr(char* s):\n"
"    cgstr o\n"
"    o.s = s;\n"
"    this:add(o);\n"
"    o:free();\n"
"end\n"
"\n"
"//predeclaration being used?!?!\n"
"method predecl codegen cgstr:fromstr(char* s);\n"
"\n"
"method codegen cgstr:fromcgstr(cgstr o):\n"
"    this:fromstr(o.s);\n"
"end\n"
"\n"
"method codegen cgstr:dupe()->cgstr:\n"
"    cgstr q;\n"
"    q:fromcgstr(this);\n"
"    return q;\n"
"end\n"
"\n"
"method codegen cgstr:fromstr(char* s):\n"
"    cgstr q\n"
"    u64 l\n"
"    \n"
"    q.s = s;\n"
"    l = q:len();\n"
"    this.s = __builtin_malloc(l+1);\n"
"    __builtin_memcpy(this.s, s, l+1);\n"
"    //this.s[l] = 0; //this was done automatically above...\n"
"    return;\n"
"end\n"
"\n"
"class cgtype\n"
"    noexport\n"
"    u64 basetype\n"
"    u64 pointerlevel\n"
"    u64 arraylen\n"
"    u64 structid\n"
"    u64 is_lvalue\n"
"\n"
"    u64 funcid\n"
"    u64 is_function\n"
"\n"
"    char* membername\n"
"end\n"
"\n"
"class cgtypedecl\n"
"    noexport\n"
"    char* name\n"
"    cgtype* members\n"
"    u64 nmembers\n"
"    u64 is_incomplete\n"
"    u64 is_noexport\n"
"    u64 is_union\n"
"    u64 algn\n"
"end\n"
"\n"
"class cgsymdecl\n"
"    noexport\n"
"    cgtype t\n"
"    char* name\n"
"    cgtype*[CG_MAX_FARGS] fargs\n"
"    u64 nargs\n"
"    u8* fbody\n"
"    u8* cdata\n"
"    u64 cdata_sz\n"
"    u64 is_pub\n"
"    u64 is_incomplete\n"
"    u64 is_codegen\n"
"    u64 is_impure\n"
"    u64 is_pure\n"
"    u64 is_inline\n"
"    u64 is_atomic\n"
"    u64 is_volatile\n"
"    u64 is_impure_globals_or_asm\n"
"    u64 is_impure_uses_incomplete_symbols\n"
"    u64 is_data\n"
"    u64 is_noexport\n"
"end\n"
"\n"
"class cgscope\n"
"    noexport\n"
"    cgsymdecl* syms\n"
"    u64 nsyms\n"
"    u8* stmts\n"
"    u64 nstmts\n"
"    u64 is_fbody\n"
"    u64 is_loopbody\n"
"end\n"
"\n"
"class cgstmt\n"
"    noexport\n"
"    cgscope* whereami\n"
"    cgscope* myscope\n"
"    u64 kind\n"
"    u8*[3] expressions\n"
"    u64 nexpressions\n"
"    cgstmt* referenced_loop\n"
"    u64 symid\n"
"    char* referenced_label_name\n"
"    char** switch_label_list\n"
"    u64* switch_label_indices\n"
"    u64 switch_nlabels\n"
"    i64 goto_scopediff\n"
"    i64 goto_vardiff\n"
"    i64 goto_where_in_scope\n"
"    u64 linenum\n"
"    u64 colnum\n"
"    char* filename\n"
"end\n"
"\n"
"class cgexpr_node\n"
"    noexport\n"
"    cgtype t\n"
"    u64 kind\n"
"    double fdata\n"
"    u64 idata\n"
"    cgexpr_node*[CG_MAX_FARGS] subnodes\n"
"    u64 symid\n"
"    u64 fnptr_nargs\n"
"    u64 constint_propagator\n"
"    char* symname\n"
"    char* method_name\n"
"    u64 is_global_variable\n"
"    u64 is_function\n"
"    u64 is_implied\n"
"    u64 was_struct_var\n"
"    cgtype type_to_get_size_of\n"
"end\n"
"\n"
"class cgtypedecl_oop_metadata\n"
"    noexport\n"
"    i64 ctor_id\n"
"    i64 dtor_id\n"
"    i64 have_checked\n"
"end\n"
"\n"
"\n"
"class cgast\n"
"    noexport\n"
"    cgtypedecl** type_table\n"
"    cgsymdecl*** symbol_table\n"
"    cgtypedecl_oop_metadata** oop_metadata;\n"
"    cgscope*** scopestack\n"
"    cgstmt*** loopstack\n"
"    \n"
"    u64* active_function\n"
"    u64* ntypedecls\n"
"    u64* nsymbols\n"
"    u64* nscopes\n"
"    u64* nloops\n"
"    u64 target_word\n"
"    u64 signed_target_word\n"
"    u64 target_max_float\n"
"end\n"
"\n"
"class cg_parser_cache noexport\n"
"    u64 active_function\n"
"    u64 nscopes\n"
"    u64 nloops\n"
"    cgscope** scopestack\n"
"    cgstmt** loopstack\n"
"end\n"
"\n"
"method codegen cg_parser_cache.save():\n"
"    cgast* ast = cast(cgast*)__builtin_get_ast();\n"
"    this.active_function = ast.active_function[0];\n"
"    this.nscopes = ast.nscopes[0];\n"
"    this.nloops = ast.nloops[0];\n"
"    this.scopestack = ast.scopestack[0];\n"
"    this.loopstack = ast.loopstack[0];\n"
"    \n"
"    ast.nscopes[0] = 0;\n"
"    ast.nloops[0] = 0;\n"
"    ast.scopestack[0] = 0;\n"
"    ast.loopstack[0] = 0;\n"
"    ast.active_function[0] = -1;\n"
"    //__builtin_puts(\"Executed a save!\");\n"
"end\n"
"\n"
"method codegen cg_parser_cache.load():\n"
"    cgast* ast = cast(cgast*)__builtin_get_ast();\n"
"    if(ast.scopestack[0] != 0)\n"
"        __builtin_free((u8*)ast.scopestack[0]);\n"
"    end\n"
"    if(ast.loopstack[0] != 0)\n"
"        __builtin_free((u8*)ast.loopstack[0]);\n"
"    end\n"
"    ast.nscopes[0] = this.nscopes;\n"
"    ast.nloops[0] = this.nloops;\n"
"    ast.scopestack[0] = this.scopestack;\n"
"    ast.loopstack[0] = this.loopstack;\n"
"    ast.active_function[0] = this.active_function;\n"
"    //__builtin_puts(\"Executed a load!\");\n"
"end\n"
"\n"
"fn codegen parsehook_global():\n"
"    cg_parser_cache pcache\n"
"    pcache.save();\n"
"    __builtin_parse_global();\n"
"    pcache.load();\n"
"end\n"
"\n"
"\n"
"class cgstrll\n"
"    noexport\n"
"    char* text\n"
"    u64 linenum\n"
"    u64 colnum\n"
"    char* filename\n"
"    u8* d //data, but data is a keyword in seabass.... I \n"
"    //probably should have thought of that, huh?\n"
"    cgstrll* right\n"
"end\n"
"\n"
"\n"
"fn codegen parsehook_globalscope():\n"
"    cgstrll* pp\n"
"    cg_parser_cache pcache\n"
"    pcache.save();\n"
"    while(1)\n"
"        pp = (cgstrll*)__builtin_peek();\n"
"        if(pp == 0) break end\n"
"        if(\n"
"            pp.d == CG_TOK_KEYWORD &&\n"
"            pp.text streq \"end\"\n"
"        )\n"
"            __builtin_consume();\n"
"            break; \n"
"        end\n"
"        __builtin_parse_global();\n"
"    end\n"
"    pcache.load();\n"
"end\n"
"\n"
"\n"
"method codegen cgstrll.dupe()->cgstrll*:\n"
"    /*\n"
"        cgstrll* retval\n"
"        retval = cast(cgstrll*)__builtin_malloc(sizeof(cgstrll));\n"
"        retval := this;\n"
"        if(cast(u64)this.text)\n"
"            retval.text = __builtin_strdup(this.text);\n"
"        end\n"
"        retval.right = cast(cgstrll*)0;\n"
"        return retval;\n"
"    */\n"
"    return cast(cgstrll*)__builtin_strll_dupe(cast(char*)this);\n"
"end\n"
"\n"
"method codegen cgstrll.dupell()->cgstrll*:\n"
"    /*\n"
"        cgstrll* retval\n"
"        cgstrll* rwalk\n"
"\n"
"        retval = this:dupe();\n"
"        this = this.right;\n"
"        rwalk = retval;\n"
"        for(0, this != cast(cgstrll*)0, this = this.right)\n"
"            rwalk.right = this:dupe();\n"
"            rwalk = rwalk.right;\n"
"        end\n"
"        return retval;\n"
"    */\n"
"    return cast(cgstrll*)__builtin_strll_dupell(cast(char*)this);\n"
"end\n"
"\n"
"\n"
"/*\n"
"    TODO: Implement a system for converting cgstrll's\n"
"    back into strings which can be passed into cg_qtok.\n"
"*/\n"
"\n"
"method codegen cgstrll:to_cstr()->char*:\n"
"    if(this.d == CG_TOK_STRING)\n"
"        //we need to STRINGIFY the string!\n"
"        cgstr p\n"
"        cgstr backslash\n"
"        cgstr quote\n"
"        cgstr f\n"
"        backslash.s = \"\\\\\";\n"
"        quote.s = \"\\\"\";\n"
"        p.fromstr(quote.s);\n"
"        p.add(quote);\n"
"        u64 len\n"
"        char* text\n"
"        text = this.text;\n"
"        for(0, text[0], text++)\n"
"            if(text[0] == '\\n')\n"
"                p:add(backslash);\n"
"                f.s = \"n\";p:add(f);\n"
"            elif(text[0] == '\\a')\n"
"                p:add(backslash);\n"
"                f.s = \"a\";p:add(f);\n"
"            elif(text[0] == '\\\"')\n"
"                p:add(backslash);\n"
"                f.s = \"\\\"\";p:add(f);\n"
"            elif(text[0] == '\\b')\n"
"                p:add(backslash);\n"
"                f.s = \"b\";p:add(f);\n"
"            elif(text[0] == '\\f')\n"
"                p:add(backslash);\n"
"                f.s = \"f\";p:add(f);\n"
"            elif(text[0] == '\\e')\n"
"                p:add(backslash);\n"
"                f.s = \"e\";p:add(f);            \n"
"            elif(text[0] == '\\\\')\n"
"                p:add(backslash);\n"
"                p:add(backslash);\n"
"            elif(text[0] == '\\r')\n"
"                p:add(backslash);\n"
"                f.s = \"r\";p:add(f);\n"
"            elif(text[0] == '\\t')\n"
"                p:add(backslash);\n"
"                f.s = \"t\";p:add(f);\n"
"            elif(text[0] == '\\v')\n"
"                p:add(backslash);\n"
"                f.s = \"v\";p:add(f);\n"
"            else\n"
"                char[2] buf\n"
"                buf[0] = text[0];\n"
"                buf[1] = 0;\n"
"                f.s = buf;p:add(f);\n"
"            end\n"
"        end\n"
"        p:add(quote);\n"
"        p:add(quote);\n"
"        return p.s;\n"
"    end\n"
"    if(1)\n"
"        cgstr retme\n"
"        cgstr quote\n"
"        cgstr temp\n"
"        quote.s = \"\\\"\";\n"
"        if(this.d == CG_TOK_OBRACK)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"[\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_CBRACK)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"]\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end  \n"
"        if(this.d == CG_TOK_OPAREN)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"(\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_CPAREN)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \")\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_OCB)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"{\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_CCB)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \"}\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end\n"
"        if(this.d == CG_TOK_SEMIC)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \";\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end    \n"
"        if(this.d == CG_TOK_COMMA)\n"
"            retme:fromstr(quote.s);\n"
"            temp.s = \",\";\n"
"            retme:add(temp);\n"
"            retme:add(quote);\n"
"            return retme.s;\n"
"        end\n"
"    end\n"
"    if(this.d != CG_TOK_STRING)\n"
"        if(this.text != 0)\n"
"            //just wrap in quotes!\n"
"            cgstr quote\n"
"            cgstr b\n"
"            cgstr a\n"
"            quote.s = \"\\\"\";\n"
"            a.s = this.text;\n"
"            b:fromstr(quote.s);\n"
"            b:add(a);\n"
"            b:add(quote);\n"
"            return b.s;\n"
"        end\n"
"    end\n"
"    char* retval\n"
"    retval = 0;\n"
"    return retval;\n"
"end\n"
"\n"
"\n"
"method codegen cgstrll:debug_print():\n"
"    :top\n"
"    if(this == 0)\n"
"        return;\n"
"    end\n"
"    if(this.d == CG_TOK_STRING)\n"
"        __builtin_puts(\"~~~string:\");\n"
"        __builtin_puts(this.text);\n"
"        __builtin_puts(\"~~~\");\n"
"    elif(cast(uptr)this.text)\n"
"        __builtin_puts(this.text);\n"
"    elif(this.d == CG_TOK_OBRACK)\n"
"        __builtin_puts(\"[\");\n"
"    elif(this.d == CG_TOK_CBRACK)\n"
"        __builtin_puts(\"]\");\n"
"    elif(this.d == CG_TOK_OPAREN)\n"
"        __builtin_puts(\"(\");\n"
"    elif(this.d == CG_TOK_CPAREN)\n"
"        __builtin_puts(\")\");\n"
"    elif(this.d == CG_TOK_OCB)\n"
"        __builtin_puts(\"{\");\n"
"    elif(this.d == CG_TOK_CCB)\n"
"        __builtin_puts(\"}\");\n"
"    elif(this.d == CG_TOK_SEMIC)\n"
"        __builtin_puts(\";\");\n"
"    elif(this.d == CG_TOK_COMMA)\n"
"        __builtin_puts(\",\");\n"
"    end\n"
"    this = this.right;\n"
"    goto top\n"
"end\n"
"\n"
"\n"
"method codegen cgstrll:push_end(cgstrll other):\n"
"    while(this.right != cast(cgstrll*)0)\n"
"        this = this.right;\n"
"    end\n"
"    this.right = other;\n"
"    return;\n"
"end\n"
"\n"
"fn codegen cgtok_push_stream(cgstrll pushme):\n"
"    cgstrll** n\n"
"    cgstrll* pretender\n"
"\n"
"    n  = cast(cgstrll**)__builtin_getnext();\n"
"    pretender = pushme;\n"
"    while(pretender.right  != cast(cgstrll*)0)\n"
"        pretender = pretender.right;\n"
"    end\n"
"    pretender.right = n[0];\n"
"    n[0] = pushme; //set next pointer.\n"
"end\n"
"\n"
"//frees the entire list including the root node.\n"
"method codegen cgstrll:freelist():\n"
"    cgstrll* r\n"
"    while(1)\n"
"        if(this == 0)\n"
"            return;\n"
"        end\n"
"        \n"
"        r = this.right;\n"
"        if(this.text != 0)\n"
"            __builtin_free(this.text);\n"
"        end\n"
"        __builtin_free(cast(u8*)this);\n"
"        this = r;\n"
"    end\n"
"end\n"
"\n"
"method codegen cgstrll:dupelen(u64 len)->cgstrll*:\n"
"    cgstrll* retval\n"
"    cgstrll* current\n"
"    cgstrll* tt\n"
"    tt = this;\n"
"\n"
"    retval = cast(cgstrll*)0;\n"
"    //return null if they asked for nothing...\n"
"    if(len == 0) \n"
"        return retval; \n"
"    end\n"
"    \n"
"    \n"
"    retval = tt:dupe();//duplicate ourselves.\n"
"    \n"
"    len--; \t\t\t     //subtract from len!\n"
"    current = retval;    //set up current.\n"
"    tt = tt.right;   //traverse right\n"
"\n"
"    while(len)\n"
"        if(tt == cast(cgstrll*)0)\n"
"            return retval;\n"
"        end\n"
"        current.right = tt:dupe();\n"
"        tt = tt.right;\n"
"        current = current.right;\n"
"        len--;\n"
"    end\n"
"    return retval;\n"
"end\n"
"\n"
"\n"
"fn codegen cg_getast()->cgast*:\n"
"    return (cgast*)__builtin_get_ast()\n"
"end\n"
"\n"
"//gets the value of the next variable.\n"
"fn codegen cg_peek()->cgstrll*:\n"
"    return cast(cgstrll*)__builtin_peek();\n"
"end\n"
"\n"
"//allows us to assign next.\n"
"fn codegen cg_getnext()->cgstrll**:\n"
"    return cast(cgstrll**)__builtin_getnext();\n"
"end\n"
"\n"
"\n"
"\n"
"fn codegen cg_token_dupe_skip(u64 len)->cgstrll*:\n"
"    cgstrll* retval\n"
"    cgstrll* walker\n"
"    retval = cg_peek():dupelen(len);\n"
"    for(\n"
"        walker = retval, \n"
"        walker != cast(cgstrll*)0, \n"
"        walker = walker.right\n"
"    )\n"
"        __builtin_consume();\n"
"    end\n"
"\n"
"    return retval;\n"
"end\n"
"\n"
"//Assumes that you pass it a list \n"
"fn codegen cg_tok_arglist_remove_brackets(cgstrll* in)->cgstrll*:\n"
"    cgstrll* retval\n"
"    cgstrll* walker\n"
"    //check if this even is bracketed.\n"
"    \n"
"    if(in.d != CG_TOK_OBRACK)\n"
"        return in;\n"
"    end\n"
"    //check for the specific and unusual case that we have an empty arglist.\n"
"    if(in.right != 0)\n"
"        if(in.right.d == CG_TOK_CBRACK)\n"
"            in:freelist();\n"
"            return cast(cgstrll*)0;\n"
"        end\n"
"    end\n"
"    //remove the first element\n"
"    retval = in.right;\n"
"    if(in.text != 0)\n"
"        __builtin_free(in.text);\n"
"        in.text = cast(char*)0;\n"
"    end\n"
"    __builtin_free(cast(u8*)in);\n"
"    in = cast(cgstrll*)0;\n"
"\n"
"    //Travel to the next-to-last element (so the last element is to our right.)\n"
"    walker = retval;\n"
"    while(1)\n"
"        if(walker.right == 0)\n"
"            __builtin_puts(\"ERROR! cg_tok_arglist_remove_brackets passed invalid arglist.\");\n"
"            __builtin_puts(\"You may not pass an empty arglist!\");\n"
"            __builtin_exit(1);\n"
"        end\n"
"         \n"
"        if(walker.right.right == cast(cgstrll*)0)\n"
"            break; \n"
"        end\n"
"        walker = walker.right;\n"
"    end\n"
"    \n"
"    //pop walker's right.\n"
"    if(walker.right.text != 0)\n"
"        __builtin_free(walker.right.text);\n"
"    end\n"
"    __builtin_free(cast(u8*)walker.right);\n"
"    walker.right = cast(cgstrll*)0;\n"
"\n"
"    return retval;\n"
"end\n"
"\n"
"method codegen cgstrll:cg_token_foldout_arglist()->cgstrll*:\n"
"    //we already have a cgstrll linked list (this)\n"
"    //we want to rip out the token list.\n"
"    \n"
"    cgstrll* retval\n"
"    cgstrll* obrack_ptr\n"
"    cgstrll* walker\n"
"    retval = cast(cgstrll*)0;\n"
"    \n"
"    //if our right is null...\n"
"\n"
"    if(this.right == 0)\n"
"        __builtin_puts(\"INTERNAL CODEGEN TIME ERROR\");\n"
"        __builtin_puts(\"cgstrll:cg_token_foldout_arglist() called on something\");\n"
"        __builtin_puts(\"Which has null on its right!\");\n"
"        __builtin_exit(1);\n"
"    end\n"
"\n"
"    \n"
"    //invalid pass-in.\t\n"
"    if(this.right.d != CG_TOK_OBRACK)\n"
"        //get a single!\n"
"        retval = this.right;\n"
"        this.right = this.right.right;\n"
"        retval.right = 0;\n"
"        return retval;\n"
"    end\n"
"    obrack_ptr = this.right; \n"
"    retval = obrack_ptr; //We want the opening bracket, actually.\n"
"\n"
"\n"
"    i64 level;\n"
"    level = 1; //skip obrack.\n"
"    walker = obrack_ptr.right;\n"
"    for(\n"
"        0,\n"
"        walker != cast(cgstrll*)0, \n"
"        0\n"
"    )\n"
"\n"
"        if(walker.d == CG_TOK_OBRACK) level++; \n"
"        elif(walker.d == CG_TOK_CBRACK) level--; end //walker will point to the closing bracket.\n"
"        \n"
"        if(level == 0) break; end\n"
"        walker = walker.right;\n"
"    end\n"
"    \n"
"    if(level != 0)\n"
"        __builtin_puts(\"INTERNAL CODEGEN TIME ERROR\");\n"
"        __builtin_puts(\"There are unmatched square brackets in the program.\");\n"
"        __builtin_puts(\"This caused cgstrll:cg_token_foldout_arglist, to fail.\");\n"
"        __builtin_puts(\"I'm returning Null. I Hope there's a more specific error message...\");\n"
"        //error by returning zero.\n"
"        retval = cast(cgstrll*)0;\n"
"        return retval;\n"
"    end\n"
"    \n"
"    this.right = walker.right; //close up the wound!\n"
"    walker.right = cast(cgstrll*)0;\n"
"    return retval;\n"
"end\n"
"\n"
"\n"
"\n"
"fn codegen cg_token_grab_arglist(char* errtext)->cgstrll*:\n"
"    cgstrll* retval\n"
"    cgstrll* p\n"
"    cgstrll* walker\n"
"    cgstrll* owalker\n"
"    p = cg_peek();\n"
"    //if there are no arguments, return no arguments!\n"
"    \n"
"    if(cast(uptr)p == 0) \t\t\n"
"        __builtin_puts(\"INTERNAL SYNTAX ERROR: Token Arglist is EMPTY!\");\n"
"        __builtin_puts(errtext);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    \n"
"    \n"
"    //if the argument is a single, return it!\n"
"    if(p.d != CG_TOK_OBRACK)\n"
"        retval = p:dupe();\n"
"        __builtin_consume();\n"
"        return retval;\n"
"    end\n"
"\n"
"    //the argument was an opening bracket...\n"
"\n"
"    //Walk the token list until we reach the end or the matching closing square bracket\n"
"\n"
"    i64 level;\n"
"    level = 1;\n"
"    retval = p:dupe();\n"
"    owalker = retval;\n"
"    __builtin_consume();\n"
"    \n"
"    while(1)\n"
"        p = cg_peek();\n"
"        if(p == 0) break\n"
"        elif(p.d == CG_TOK_OBRACK) level++; \n"
"        elif(p.d == CG_TOK_CBRACK) level--; end\n"
"        owalker.right = p:dupe();\n"
"        owalker = owalker.right;\n"
"        __builtin_consume();\n"
"        if(level == 0) break; end\n"
"    end\n"
"    \n"
"    \n"
"    if(level != 0)\n"
"        __builtin_puts(\"INTERNAL SYNTAX ERROR: Token Arglist has mismatched square brackets!\");\n"
"        __builtin_puts(errtext);\n"
"        __builtin_exit(1);\n"
"    end\n"
"    \n"
"    return retval;\n"
"end\n"
"\n"
"//Traverse token list, grab args (single token or [nest of [token sets] to parse])\n"
"\n"
"\n"
"//build a token- from scratch!\n"
"//TODO is to automatically detect\n"
"//what the token should be.\n"
"fn codegen cg_buildtok(\n"
"    char* text,\n"
"    u64 id,\n"
"    u64 linenum,\n"
"    u64 colnum,\n"
"    char* filename,\n"
"    u8* d,\n"
"    cgstrll* right\n"
")->cgstrll*:\n"
"    //allocated on the heap just like everything else, of course.\n"
"    cgstrll* p;\n"
"    p = cast(cgstrll*)__builtin_malloc(sizeof(cgstrll));\n"
"    \n"
"    p.text = text;\n"
"    p.linenum = linenum;\n"
"    p.colnum = colnum;\n"
"    p.filename = filename;\n"
"    p.d = d; //this is really our identification.\n"
"    p.right = right;\n"
"    return p;\n"
"end\n"
"\n"
"//automatic token building.\n"
"fn codegen cg_autobuildtok(\n"
"    char* text,\n"
"    int is_string,\n"
"    int is_ident,\n"
"    int is_int,\n"
"    int is_float,\n"
"    int is_keyw,\n"
"    int is_operator\n"
")->cgstrll*:\n"
"    //it will strdup a pointer for you for all these.\n"
"    if(is_string)\n"
"        return cg_buildtok(\n"
"            __builtin_strdup(text), 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_STRING,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(is_ident)\n"
"        return cg_buildtok(\n"
"            __builtin_strdup(text), 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_IDENT,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(is_int)\n"
"        return cg_buildtok(\n"
"            __builtin_strdup(text), 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_INT_CONST,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(is_float)\n"
"        return cg_buildtok(\n"
"            __builtin_strdup(text), 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_FLOAT_CONST,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\n"
"    if(is_keyw)\n"
"        return cg_buildtok(\n"
"            __builtin_strdup(text), 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_KEYWORD,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\n"
"    if(is_operator)\n"
"        return cg_buildtok(\n"
"            __builtin_strdup(text), 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_OPERATOR,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\n"
"    //it was not a string- detect simple cases.\n"
"    if(text streq \"(\") \n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_OPAREN,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(text streq \")\") \n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_CPAREN,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(text streq \"{\") \n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_OCB,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(text streq \"}\")\n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_CCB,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(text streq \"[\")\n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_OBRACK,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(text streq \"]\")\n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_CBRACK,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\tif(text streq \";\")\n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_SEMIC,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\t\n"
"    if(text streq \",\")\n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_COMMA,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\n"
"    if(text streq \"#\")\n"
"        return cg_buildtok(\n"
"            cast(u8*)0, 0,\n"
"            0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_MACRO_OP,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\n"
"    //dump case\n"
"    if(1)\n"
"        return cg_buildtok(\n"
"            text,\n"
"            0,0,0,\n"
"            \"AUTO_GENERATED_NOT_REAL\",\n"
"            CG_TOK_UNKNOWN,\n"
"            cast(cgstrll*)0\n"
"        );\n"
"    end\n"
"end\n"
"\n"
"fn codegen cg_is_operator(char* text)->u8:\n"
"    if(text streq \"++\") return 1; end\n"
"    if(text streq \"--\") return 1; end\n"
"    if(text streq \":=\") return 1; end\n"
"    if(text streq \":\") return 1; end\n"
"    if(text streq \"<=\") return 1; end\n"
"    if(text streq \"<\") return 1; end\n"
"    if(text streq \">=\") return 1; end\n"
"    if(text streq \">\") return 1; end\n"
"    if(text streq \"!=\") return 1; end\n"
"    if(text streq \"==\") return 1; end\n"
"    if(text streq \"===\") return 1; end\n"
"    if(text streq \"->\") return 1; end\n"
"    if(text streq \".&\") return 1; end\n"
"    if(text streq \"&\") return 1; end\n"
"    if(text streq \"&&\") return 1; end\n"
"    if(text streq \"|\") return 1; end\n"
"    if(text streq \"||\") return 1; end\n"
"    if(text streq \">>\") return 1; end\n"
"    if(text streq \"<<\") return 1; end\n"
"    \n"
"    if(text streq \"~\") return 1; end\n"
"    if(text streq \"!\") return 1; end\n"
"    if(text streq \".\") return 1; end\n"
"    if(text streq \"&\") return 1; end\n"
"    if(text streq \"*\") return 1; end\n"
"    if(text streq \"+\") return 1; end\n"
"    if(text streq \"-\") return 1; end\n"
"    if(text streq \"/\") return 1; end\n"
"    if(text streq \"%\") return 1; end\n"
"    if(text streq \"<\") return 1; end\n"
"    if(text streq \">\") return 1; end\n"
"    if(text streq \"^\") return 1; end\n"
"    if(text streq \"|\") return 1; end\n"
"    if(text streq \"?\") return 1; end\n"
"    if(text streq \"=\") return 1; end\n"
"    if(text streq \"@\") return 1; end\n"
"\n"
"    if(text streq \"streq\") return 1; end\n"
"    if(text streq \"strneq\") return 1; end\n"
"    \n"
"    if(text streq \"eq\") return 1; end\n"
"    if(text streq \"neq\") return 1; end\n"
"    return 0;\n"
"end\n"
"\n"
"fn codegen cg_is_keyw(char* text)->u8:\n"
"    if(text streq \"fn\") return 1; end\n"
"    if(text streq \"function\") return 1; end\n"
"    if(text streq \"func\") return 1; end\n"
"    if(text streq \"procedure\") return 1; end\n"
"    if(text streq \"proc\") return 1; end\n"
"    if(text streq \"cast\") return 1; end\n"
"\n"
"    if(text streq \"u8\") return 1; end\n"
"    if(text streq \"char\") return 1; end\n"
"    if(text streq \"byte\") return 1; end\n"
"    if(text streq \"ubyte\") return 1; end\n"
"    if(text streq \"uchar\") return 1; end\n"
"\n"
"    if(text streq \"i8\") return 1; end\n"
"    if(text streq \"schar\") return 1; end\n"
"    if(text streq \"sbyte\") return 1; end\n"
"\n"
"    if(text streq \"u16\") return 1; end\n"
"    if(text streq \"ushort\") return 1; end\n"
"    \n"
"    if(text streq \"i16\") return 1; end\n"
"    if(text streq \"short\") return 1; end\n"
"    if(text streq \"sshort\") return 1; end\n"
"\n"
"    if(text streq \"u32\") return 1; end\n"
"    if(text streq \"uint\") return 1; end\n"
"    if(text streq \"ulong\") return 1; end\n"
"\n"
"    if(text streq \"i32\") return 1; end\n"
"    if(text streq \"int\") return 1; end\n"
"    if(text streq \"sint\") return 1; end\n"
"    if(text streq \"long\") return 1; end\n"
"    if(text streq \"slong\") return 1; end\n"
"\n"
"    if(text streq \"u64\") return 1; end\n"
"    if(text streq \"ullong\") return 1; end\n"
"    if(text streq \"uqword\") return 1; end\n"
"    if(text streq \"qword\") return 1; end\n"
"    if(text streq \"uptr\") return 1; end\n"
"\n"
"    \n"
"    if(text streq \"i64\") return 1; end\n"
"    if(text streq \"sllong\") return 1; end\n"
"    if(text streq \"llong\") return 1; end\n"
"    if(text streq \"sqword\") return 1; end\n"
"    \n"
"    if(text streq \"noexport\") return 1; end\n"
"\n"
"    if(text streq \"f32\") return 1; end\n"
"    if(text streq \"f64\") return 1; end\n"
"    if(text streq \"float\") return 1; end\n"
"    if(text streq \"double\") return 1; end\n"
"\n"
"    if(text streq \"break\") return 1; end\n"
"    if(text streq \"data\") return 1; end\n"
"    if(text streq \"string\") return 1; end\n"
"    if(text streq \"end\") return 1; end\n"
"    if(text streq \"continue\") return 1; end\n"
"    if(text streq \"if\") return 1; end\n"
"    if(text streq \"else\") return 1; end\n"
"    if(text streq \"while\") return 1; end\n"
"\n"
"    if(text streq \"goto\") return 1; end\n"
"    if(text streq \"jump\") return 1; end\n"
"\n"
"    if(text streq \"return\") return 1; end\n"
"    if(text streq \"tail\") return 1; end\n"
"    if(text streq \"sizeof\") return 1; end\n"
"    if(text streq \"static\") return 1; end\n"
"    if(text streq \"pub\") return 1; end\n"
"    if(text streq \"public\") return 1; end\n"
"\n"
"    if(text streq \"struct\") return 1; end\n"
"    if(text streq \"class\") return 1; end\n"
"    if(text streq \"union\") return 1; end\n"
"    if(text streq \"asm\") return 1; end\n"
"    if(text streq \"method\") return 1; end\n"
"    if(text streq \"predecl\") return 1; end\n"
"    if(text streq \"codegen\") return 1; end\n"
"\n"
"    if(text streq \"constexpri\") return 1; end\n"
"    if(text streq \"constexprf\") return 1; end\n"
"    if(text streq \"switch\") return 1; end\n"
"    if(text streq \"for\") return 1; end\n"
"\n"
"    if(text streq \"elif\") return 1; end\n"
"    if(text streq \"elseif\") return 1; end\n"
"\n"
"    if(text streq \"pure\") return 1; end\n"
"    if(text streq \"inline\") return 1; end\n"
"\n"
"    if(text streq \"atomic\") return 1; end\n"
"    if(text streq \"volatile\") return 1; end\n"
"\n"
"    if(text streq \"getfnptr\") return 1; end\n"
"    if(text streq \"callfnptr\") return 1; end\n"
"    if(text streq \"getglobalptr\") return 1; end\n"
"\n"
"    return 0;\n"
"end\n"
"\n"
"fn codegen cg_process_stringlit(char* text):\n"
"    //remove starting and ending quotes.\n"
"    cgstr q\n"
"    \n"
"    \n"
"    cgstrcpy(text, text+1);//remove first character- a quote\n"
"    q.s = (text); //move to cgstring\n"
"    q.s[q:len()-1] = 0; //remove last character- a quote\n"
"\n"
"    //for each character\n"
"    i64 i\n"
"    i64 len\n"
"    len = q:len();\n"
"    for(i = 0, i < len, i++)\n"
"        if(q.s[i] == '\\\\')\n"
"            //skip\n"
"            if(q.s[i+1] == 0)\n"
"                continue;\n"
"            elif(q.s[i+1] == 'a')\n"
"                q.s[i] = '\\a';\n"
"\n"
"                cgstrcpy(\n"
"                    q.s+i+1, \n"
"                    q.s+i+2\n"
"                );\n"
"                continue;\n"
"            elif(q.s[i+1] == 'b')\n"
"                q.s[i] = '\\b';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"            elif(q.s[i+1] == 'e')\n"
"                q.s[i] = '\\e';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"            elif(q.s[i+1] == 'f')\n"
"                q.s[i] = '\\f';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"\n"
"            elif(q.s[i+1] == 'n')\n"
"                q.s[i] = '\\n';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"\n"
"            elif(q.s[i+1] == 'r')\n"
"                q.s[i] = '\\r';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"            elif(q.s[i+1] == 't')\n"
"                q.s[i] = '\\t';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"\n"
"            elif(q.s[i+1] == 'v')\n"
"                q.s[i] = '\\v';\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"            else\n"
"                //literally that character...\n"
"                q.s[i] = q.s[i+1];\n"
"                cgstrcpy(q.s+i+1, q.s+i+2);\n"
"                continue;\n"
"            end //eof if-elif chain.\t\n"
"        end //eof if\n"
"    end //eof for loop\n"
"end //eof function\n"
"\n"
"/*\n"
"    REMINDER\n"
"    cg_autobuildtok(\n"
"        char* text,\n"
"        int is_string,\n"
"        int is_ident,\n"
"        int is_int,\n"
"        int is_float,\n"
"        int is_keyw,\n"
"        int is_operator\n"
"    )\n"
"*/\n"
"\n"
"\n"
"fn codegen cg_qtok(\n"
"    char* text\n"
")->cgstrll*:\n"
"    cgstrll* retval;\n"
"    text = __builtin_strdup(text); //avoid trouncing the original string.\n"
"    //1. recognize strings.\n"
"    if(text[0] == '\\\"')//this is a string.\n"
"        cg_process_stringlit(text);\n"
"        retval = cg_autobuildtok(\n"
"            text,\n"
"            1,\n"
"            0,\n"
"            0,\n"
"            0,\n"
"            0,\n"
"            0\n"
"        );\n"
"        __builtin_free(text);\n"
"        return retval;\n"
"    end\n"
"    if(text[0] == '\\'') //this is a character literal.\n"
"        cgstr q\n"
"        cg_process_stringlit(text);\n"
"        //create a string for storage of a single 3 digit number.\n"
"        q:fromstr(\"   \");\n"
"        //convert character to text integer\n"
"        __builtin_itoa(q.s, cast(u32)text[0]);\n"
"        __builtin_free(text);\n"
"        retval = cg_autobuildtok(\n"
"            q.s,\n"
"            0,\n"
"            0,\n"
"            1,\n"
"            0,\n"
"            0,\n"
"            0\n"
"        );\n"
"        q:free();\n"
"        //return the token.\n"
"        return retval;\n"
"    end\n"
"    if(cg_is_keyw(text))\n"
"        retval = cg_autobuildtok(\n"
"            text,\n"
"            0, //is_string\n"
"            0, //is_ident\n"
"            0, //is_int\n"
"            0, //is_float\n"
"            1, //is_keyw\n"
"            0  //is_operator\n"
"        );\n"
"        __builtin_free(text);\n"
"        return retval;\n"
"    end\n"
"    if(cg_is_operator(text))\n"
"        retval = cg_autobuildtok(\n"
"            text,\n"
"            0, //is_string\n"
"            0, //is_ident\n"
"            0, //is_int\n"
"            0, //is_float\n"
"            0, //is_keyw\n"
"            1  //is_operator\n"
"        );\n"
"        __builtin_free(text);\n"
"        return retval;\n"
"    end\n"
"\n"
"    \n"
"    //does this match the prototype of an identifier?\n"
"    cgstr qq;\n"
"    qq.s = text;\n"
"    \n"
"    if(\n"
"        (qq:len() > 0) &&\n"
"        (\n"
"            cgisalpha(text[0]) ||\n"
"            (text[0] == '_')\n"
"        )\n"
"    )\n"
"        retval = cg_autobuildtok(\n"
"            text,\n"
"            0, //is_string\n"
"            1, //is_ident\n"
"            0, //is_int\n"
"            0, //is_float\n"
"            0, //is_keyw\n"
"            0  //is_operator\n"
"        );\n"
"        __builtin_free(text);\n"
"        return retval;\n"
"    end\n"
"    \n"
"    //int or float.\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    //INT OR FLOAT DETECTOR\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    if(cgisdigit(text[0]))\n"
"        //detect hex\n"
"        if(\n"
"            text[0] == 'x' ||\n"
"            text[0] == 'X'\n"
"        )\n"
"            goto is_integer\n"
"        end\n"
"        //detect float\n"
"        if(1)\n"
"            cgstr tmp\n"
"            cgstr findme\n"
"            tmp.s = text;\n"
"            findme.s = \".\";\n"
"            if(tmp:find(findme) != -1)\n"
"                jump is_float\n"
"            end\n"
"            //contains an \"e\" portion: power of 10.\n"
"            findme.s = \"E\";\n"
"            if(tmp:find(findme) != -1)\n"
"                jump is_float\n"
"            end\n"
"            findme.s = \"e\";\n"
"            if(tmp:find(findme) != -1)\n"
"                jump is_float\n"
"            end\n"
"        end\n"
"        //it is an integer!\n"
"        jump is_integer\n"
"    end\n"
"\n"
"    //This is something else. have autobuildtok figure it out.\n"
"    //just send it and then free the text.\n"
"    retval = cg_autobuildtok(\n"
"        text,\n"
"        0, //is_string\n"
"        0, //is_ident\n"
"        0, //is_int\n"
"        0, //is_float\n"
"        0, //is_keyw\n"
"        0  //is_operator\n"
"    );\n"
"    retval.text = cast(char*)0;\n"
"    __builtin_free(text);\n"
"    return retval;\n"
"\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    //POST_FUNCTION_PORTION\n"
"    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
"    :is_integer\n"
"        retval = cg_autobuildtok(\n"
"            text,\n"
"            0, //is_string\n"
"            0, //is_ident\n"
"            1, //is_int\n"
"            0, //is_float\n"
"            0, //is_keyw\n"
"            0  //is_operator\n"
"        );\n"
"        __builtin_free(text);\n"
"        return retval;\n"
"    :is_float\n"
"        retval = cg_autobuildtok(\n"
"            text,\n"
"            0, //is_string\n"
"            0, //is_ident\n"
"            0, //is_int\n"
"            1, //is_float\n"
"            0, //is_keyw\n"
"            0  //is_operator\n"
"        );\n"
"        __builtin_free(text);\n"
"        return retval;\n"
"end //eof cg_qtok\n"
"\n"
"/*\n"
"    \n"
"*/\n"
"\n"
"fn codegen cgast_struct_size_test():\n"
"    if(sizeof(cgtype) != __builtin_struct_metadata(0))\n"
"        __builtin_puts(\"fail: cgtype\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgtype\");\n"
"    end\n"
"\n"
"    if(sizeof(cgtypedecl) != __builtin_struct_metadata(1))\n"
"        __builtin_puts(\"fail: cgtypedecl\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgtypedecl\");\n"
"    end\n"
"\n"
"    if(sizeof(cgsymdecl) != __builtin_struct_metadata(2))\n"
"        __builtin_puts(\"fail: cgsymdecl\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgsymdecl\");\n"
"    end\n"
"\n"
"    if(sizeof(cgscope) != __builtin_struct_metadata(3))\n"
"        __builtin_puts(\"fail: cgscope\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgscope\");\n"
"    end\n"
"\n"
"    if(sizeof(cgstmt) != __builtin_struct_metadata(4))\n"
"        __builtin_puts(\"fail: cgstmt\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgstmt\");\n"
"    end\t\n"
"    if(sizeof(cgexpr_node) != __builtin_struct_metadata(5))\n"
"        __builtin_puts(\"fail: cgexpr_node\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgexpr_node\");\n"
"    end\t\n"
"\n"
"    if(sizeof(cgast) != __builtin_struct_metadata(6))\n"
"        __builtin_puts(\"fail: cgast\");\n"
"    else\n"
"        __builtin_puts(\"pass: cgast\");\n"
"    end\t\n"
"    \n"
"    if(sizeof(cgtypedecl_oop_metadata) != __builtin_struct_metadata(7))\n"
"        __builtin_puts(\"fail: cgtypedecl_oop_metadata\")\n"
"    else\n"
"        __builtin_puts(\"pass: cgtypedecl_oop_metadata\")\n"
"    end\n"
"    \n"
"end\n"
""
