<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SEABASS</title>
    <script></script>
  </head>
  <body>
    <!-- Content -->
    <center>
    <h1>
        SEABASS Metaprogramming Language
    </h1>
    <hr>
    <img src="logo.png" alt="logo" style="width:100%">
    <hr>
    </center>
    <!-- Index-->
    <hr>
    <div style="margin-left:10%;">
        <a href="#intro">Forword</a><br>
        <a href="#rattle">Call to Action</a><br>
        <a href="#mentalflux">Cognitive Theory</a><br>
        <a href="#supertool">Seabass as a Cognition-Enabling Supertool</a><br>
        <a href="#langdesign">Language Design</a><br>
        <a href="#projstate">Project State</a><br>
    </div>
    <hr>
    <center>
    <h3>All Glory to the Lord Jesus Christ, whose gifts (which I do not deserve) I rely on. Amen.</h3>
    </center>
    <hr>
    <center>
    <h2 id="intro">Foreword / Manifesto</h2>
    </center>
    <hr>
    <p><b>The mind of man is an analytical engine of unfathomable power.</b></p>
    <p></p>
    <p>Nothing we've ever made has come even remotely close. Our minds are capable of creativity and comprehension to a degree which no other thinking machine we've ever found can replicate.</p>
    <p>It is an analytical engine designed by <b>God himself</b>, formed on the sixth day as part of man, made in his own image. It is not merely a glob of cells haphazardly smacked together across millions of <i>(fictional)</i> years of selective pressures.</p>
    <p>Most of the world willfully ignores this truth, instead choosing to believe changing creature myths and pipe dreams of space explosions.</p>
    <p>Thus, because I have this knowledge, granted to me by the grace and generosity of our Lord Jesus Christ, I have seen clearly that the goal of computer science should not be to replace the mind of man (All we will ever do is make a cheap imitation) but to <b>harness it</b>.</p>
    <p>We should seek to leverage its power to the greatest possible degree. Figure out how to tap into the mind's true powers and use them as effectively as possible.</p>
    <p>This indefinite objective is the route of conquest I have chosen for my work, and SEABASS is the first of my intellectual super-weapons.</p>
    <p>Seabass allows me to create arbitrary abstractions as I devise them and make them into named "things" in the language, not only bringing the language closer to my existing thinking, but also enabling me to "play with" my ideas in a way that no other programming language I know could ever hope to do, enabling me to improve my own thinking.</p>
    <p>Where other languages would require me to re-iterate complex ideas to it over and over again just to convey the same concept, Seabass's metaprogramming paradigms allow for arbitrary concept modelling via mutable syntax.</p>
    <p>Furthermore, using Seabass, I can write tools to develop on virtually any platform, Not just ones which are compatible with Seabass's base level language, thanks to its ability to define custom code generators.</p>
    <center>
        <h2 id="rattle"><i>Rattle your sabers!</i></h2>
    </center>
    <center>
    <p>The place is here and the time is now to wage unrelenting war on the darkness and confusion. The veil of mysteries that surrounds us.</p>
    <p>Ascend to your rightful place, O man, as</p>
        <h2>Grand Master of Vision</h2>
        <h2><i>&</i></h2>
        <h2>Conqueror of Mysteries</h2>
    </center>
    <hr>
    <center>
    <h1 id="mentalflux">Cognitive Theory</h1>
    </center>
    <hr>
    <p>I have spent much of my life studying the machinations of my own mind, trying to introspect. After years and years of cooking in my head, I have devised a basic (incomplete, but I believe mostly correct) model for cognition. My theory is still developing and it may be wrong, so please do not take it as authoritative- it is merely a summary of my own findings, and the conclusions I have drawn.</p>
    <p>I model cognition as working by Pattern matching and Pattern re-application. The underlying structure of your mind, as I theorize it, is a general-purpose networked pattern-matching automata. Input from the senses is received and matched against existing knowledge and understanding, but it doesn't stop there. Pattern matching happens <i>recursively, non-deterministically, and in-parallel</i> in your head. Sensory input is not the only subject of cognition, but the contents of the mind itself as well. When you think or analyze, what you're actually doing is taking two different patterns and trying to pattern match between them (Which I call "pattern application"). This can be nested virtually infinitely with thousands if not millions of patterns all being used at once, creating sort of a "moving cyclone" of pattern matching travelling through the mind, ultimately resulting in a "train of thought".
    </p>
    <p>The more pattern match attempts are made, the better that pattern matching is, and the more useful patterns you have to be matched against, the better your thinking is. Thus, we have three distinct vectors for "intelligence advancement":</p>
    <ol>
        <li>Activation- How many pattern match attempts per second are happening?</li>
        <li>Quality- How well are patterns matched?</li>
        <li>Background- How broad is the set of patterns being matched against?</li>
    </ol>
    <p>I have found that "activation" is possible by forcing yourself to solve hard puzzles or math problems. It has to be something that forces you "on" and you have to believe it is important. Something to move you out of mental relaxation into cognitive overdrive.</p>
    <p>"Quality" I have yet to understand and is largely theoretical, sort of like a universal multiplier to the whole system. I imagine it as a cognitive efficiency coefficient describing how well your neurons work. I hypothesize it is optimized by having an optimal nutrient intake and a healthy cardiovascular system.</p>
    <p>"Background" is perhaps the most intriguing and I believe the most powerful. The most straightforward way to improve background is to be broadly educated- however that is not the only trick. Patterns from different areas of your understanding need to be able to "work together" to maximize education's impact. You need to merge insight from multiple domains of your thinking to have as wide a base of patterns to match against as possible. Being educated in three fields and being able to think only within those three disciplines is like being three times as intelligent. Being educated in three fields and being able to use things from all those different fields together is closer to being n-cubed intelligent. Hopefully I don't have to tell you that's a huge difference when, say, N is several million.</p>
    <p>Background can be maximized by forcing your brain to think in new and different ways. Multiple perspectives, multiple angles. Shots from a different angle. Different ways of analyzing things. Getting out of the groove.</p>
    <h2>Background- Recursive stimulation is generally less powerful</h2>
    <p>It is my experience that external stimuli are generally more effective at utilizing a person's mental faculties than purely internal ones. This is, I believe, why viewing diagrams or animated explanations is more effective than simply reading words out of a book. When you view an animation or look at a diagram, more of your senses are involved in the cognitive process, and therefore, you are thinking more effectively.</p>
    <h2>Is there a benefit to concentration (intellectually?) and thus a desire not to have a broad set of patterns (which just behave like noise)?</h2>
    
    <p>The thinking goes like this: If you have a broader set of patterns to match against, does that mean you will have a harder time making relevant pattern matches? Is there a 'sweet spot' for cognitive relevance that causes increases in background to be non-useful?</p>
    
    <p>My reponse? Perhaps. However, my belief is that this critical point is far beyond current utilization. We are so vastly entrenched in the 'narrow-minded' side of the balance that this objection is likely... irrelevant</p>
    <h2>What does this have to do with programming languages?</h2>
    <p>Different programming languages give you different ways of expressing computer programs. They provide you with new and different ways of thinking about your computational problems, even if the only thing that's different is "look 'n feel", because it does change how you think about it.</p>
    <p>Having multiple different ways of tackling the same programming problem increases the number of angles. It increases the spectrum and variety of patterns available to be matched against. It lets you close the gap between the "tunnels" in your mind and force pattern matches between domains. Arbitrary abstraction also offloads unnecessary or redundant thinking, "shooting down the same alleyway" over and over again, so that you can do new creative thinking.</p>

    <p></p>
    <p></p>
    <p></p>
    <hr>
    <center>
    <h1 id="supertool">Seabass as a Cognition-Enabling Supertool</h1>
    </center>
    <hr>
    <p>Seabass's base level language is a C-clone with Lua syntax sugars and some minimal object oriented programming stuff (constructors and destructors).</p>
    <p>If it stopped there? it would be entirely forgettable; redundant, even. </p>
    <p>The key of power behind Seabass is its metaprogramming facilities, which make it possible to make completely custom syntaxes and write code for arbitrary targets.</p>
    <p>This enables you to model computation in whatsoever way you find convenient or powerful to think about. Enable seeing things from different perspectives instead of trapping yourself in a box.</p>
    <p>The ability to have multiple different syntaxes all work together serves another purpose as well: it provides the programmer with multiple viable ways of approaching his problems, and they can all be mixed and matched together. Thus, it directly answers the underlying needs implied by the <b>Background</b> idea of my cognitive theory (Although we can do better- just wait).</p>
    <br>
    <h2>Does seabass answer any of the other cognitive concerns?</h2>
    <p>For <b>Activation</b>, perhaps. Seabass's ability to create arbitrary abstractions and write code for arbitrary targets, combined with its friendly base-level syntax, should make programming more fun, meaning that activation happens more often (because you care about your work; you are motivated).</p>
    <p>Because of the nature of <b>Quality</b> I don't know how a programming language could answer it, because it is pretty much purely biological. Seabass might be less stressful to write and thereby change body chemistry (improving <b>Quality</b>) but I don't know.</p>
    <br>
    <h2>Can a superior cognitive assistance tool be made which supersedes Seabass?</h2>
    <p>Without a doubt, yes. During the development of Seabass I have had numerous ideas for how to write a better metaprogramming tool.</p>
    <p>The most obvious failure of programming languages as we know them is that they are purely text-based. There is little-to-no graphical or audio element, and therefore a much lesser degree of mental stimulation (lesser activation) and fewer perspectives from which to work.</p>
    <p>Having the maximum 'possible routes of investigation' is the whole idea behind maximizing background, and therefore we need to involve as many of man's senses as we can.</p>
    <p>Furthermore, I believe that an audio-visual programming experience could be more like a puzzle video game and therefore be more fun.</p>
    <p>Seabass is purely text-based. While it may be possible to make a graphical equivalent, I suspect that once audio-visual programming tools become the norm, seabass will quickly become outdated.</p>
    <hr>
    <center>
    <h1 id="langdesign">Language Design</h1>
    </center>
    <hr>
    <p>Seabass's base level language was designed with influences from C, Lua, Rust, C++, and BASIC.</p>
    <p>If you look at code written in the language, you will notice that it does not use any curly braces.</p>
    <p>This is taken straight out of the playbook of Lua, which was my primary inspiration for the main syntax. I actively thought "I wish this was more like lua"</p>
    <p>As mentioned before, Seabass's primary features are its metaprogramming facilities- which make it a real tool rather than a toy compiler.</p>
    <p>The appearance of custom notations may look however you like (With some minor restrictions- you may not use whitespace, for instance). So ultimately, discussion of the base-level language's syntax is necessary only for bootstrapping the higher level languages you will actually write your programs in.</p>
    <p>The built-in manual pages provide the main documentation for seabass. To view them, run `cbas -m help`.</p>
    <p>Example code for the base-level language is viewable by running `cbas -m syntax`. That should tell you most of what you need to know about the base level language to write simple programs.</p>
    <p>Proper tutorials for all of the language's features should come eventually, however at time of writing, the metaprogramming library is not finished, and I am still modifying the compiler.</p>
    <hr>
    <center>
    <h1 id="projstate">Project State</h1>
    </center>
    <hr>
    <p>As I see it, this is the rough roadmap of the project at time of writing.</p>
    <ol>
        <li>UAST manipulation tools- Everything you need to make/manipulate/traverse a UAST needs to be implemented. I need to plan what those are, because it's not clear right now what they are.</li>
        <li>Parser templates- Now that cgrdparse has its very own parsehook system, I want to leverage it. I want stuff to automatically write all the code necessary to do a binary expression operator tree, and I want it to work with the UAST.</li>
        <li>OOPSY- A borrow-checked graceful error-handling programming language to beat Rust in terms of safety. I want it to feel like lua and javascript</li>
        <li>Standard library- I want Seabass to have a standard library for usermode C applications.</li>
        <li>I want to write some more example programs in Seabass/OOPSY. These will be used to demonstrate the power of the language.</li>
        <li>Metaprogramming library- A full suite of metaprogramming library tools, for the authoring of parsehooks and code generators, should be written.</li>
        <li>Tutorials/Docs- I want to make documentation and learning tutorials for how to use Seabass to write software, including the Metaprogramming library.</li>
        <li>Self-hosting- I want Seabass to compile itself. This will also aid in formal verification of the correctness of the implementation.</li>
        <li>Text Editor- I want a text editor designed specifically for editing seabass code (but capable of editing any language). I have big plans for it.</li>
    </ol>
    <p>The project should be "fit for professional use" once the language is self-hosting.</p>
    <hr>
    <center>
    <h1>TODO: Write more documentation</h1>
    </center>
    <hr>
    <p>As mentioned before, the language is still being developed and the metaprogramming library isn't finished. Furthermore, it's not self-hosting yet and therefore formal verification is virtually impossible.</p>
    <p>More documentation should be possible later.</p>
    <p></p>
    <p></p>
    <p></p>
  </body>
</html>
