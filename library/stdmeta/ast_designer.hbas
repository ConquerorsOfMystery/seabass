

#guard compiletime_ast_designer_lowlevel_DMHSW

#include <stdmeta/wksht.hbas>
#include <stdmeta/cgrdparse.hbas>



/*
    PLAN- THE AST DESIGNER
    
    Create a set of structs, possibly with circular dependency graphs (i.e. A->B->A) that
    represents your language, then write functions and methods that act on AST nodes.
    
    HOW DO I REPRESENT CIRCULAR DEPENDENCIES FOR STRUCTS IN MY LANGUAGE?
    
    1. all references to other nodes are turned into byte*. We can then turn all .member accesses
    into (  :member_reader()[0]). This is not completely bulletproof, though, and honestly it seems
    like it creates more problems than it solves...
    
    2. Define structs while you're defining structs. This is all compiletime CBAS, which means
    we don't need to go through the toc translator... so we *could* create circular dependencies
    as long as we only have pointer members. Not a big deal, right?
    
    3. We could constrict AST interaction within our AST manipulation code so that all AST interactions
    can easily be parsed, and then trick 1 can be applied. This is my best idea. Fundamentally, all
    AST interactions are inevitably member reads or writes (member access)... so... what's wrong?
    
    @cg_astdsgn_access_member [parent_expr] name
    
    which will turn into
    
    ((parent_expr):__name__()[0])
    
    This is a "low level interface" upon which I will design later implementations... it solves a problem
    that higher level tools need solved in order to function.
    
    HOW DO I GENERATE AST MANIPULATION CODE?
    
    Well, I figure much like cgrdparser, it's basically just CBAS with some macros, minor new language constructs, and syntax sugars.
    
    These manipulation functions are then written as members of the nodes.
    
    Setters and getters need to be written for every single one of a node's members, including
    vector member accesses.
    
    Code to manipulate AST nodes should be written in a DSL specifically designed for manipulating
    AST nodes. It should generally be CBAS, but with special statements for manipulating AST
    state (this makes writing the DSL easier).
    
    
    
    FORMAT
    
    @cg_astdesigner[
        myAST
        [
            myNode1* a
            myNode2* b
            @vec[myNode3*] c
        ]
        myNode1[
            int x
            char* y
        ]
        myNode2[
            myNode1* zz
        ]
        myNode3[
            @vec[myAST*] zzz
        ]
        method myNode3.visit()->myNode3* [
            //put code here...
        ]
    ]
    
*/





//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//TREE DESIGNER
//
//lay out all the node types for a tree with ease!
//useful for writing ASTs!
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

struct cg_tree_node_types_struct_def
noexport
    cgstrll* name
    cgstrll* content
end

/*
    Tree designer...
    
    @treenodes[
        mynode1[
            bla bla
        ]
        mynode2[
            bla bla
        ]
    ]
*/
@cgrdparser[
    cg_tree_types
    [
        @cgvec[cg_tree_node_types_struct_def] tree_structs
    ]
    head[
        this.tree_structs.ctor();
        while(1)
            finish_on_tok_null
            ident[
                do parse_node
            else
                @pprint[
                    /   "cg_tree_node_types SYNTAX ERROR"
                    /   "Expected Identifier, got this instead:"
                ]
                tok.debug_print();
                @pprint[
                    /   "File:"
                    /   (tok.filename)
                    /   "Line:"
                    /int(tok.linenum)
                    /   "Col:"
                    /int(tok.colnum)
                ]
                __builtin_exit(1);
            ]
            
        end
    ]
    parse_node[
        cg_tree_node_types_struct_def dd
        dd.name = 0;
        dd.content = 0;
        //grab the thing immediately right of the name- the contents of the struct in brackets
        @cg_bldr_foldout_arg [dd.content] [tok.right]
        dd.name = tok.dupe();
        eat //this eats the name...
        
        this.tree_structs.push(dd);
        finish
    ]
    finish[
        i64 i
        i64 len = this.tree_structs.len;
        emitq ";"
        if(len <= 0)
            finish
        end
        //there is at least one struct declared!
        for(i = 0; i < len; i++)
            emitq "@"
            emitq "global"
            emitq "struct"
            emit [this.tree_structs.d[i].name]
            emitq "noexport"
        end
        //emit contents of structs...
        for(i = len-1; i >= 0; i--)
            emit [this.tree_structs.d[i].content]
            emit_skip
            emitq "end"
        end
    ]
]
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*
    AST DESIGNER
*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


struct cg_astdesigner_fn_def
    noexport
    cgstr name
    cgstrll* code_in
    cgstrll* code_out
end

struct cg_astdesigner_struct_def
    noexport
    cgstr name;
    cgstrll* contents_in //before name mangling
    cgstrll* contents_out //after name mangling
    @cgvec[cg_astdesigner_fn_def*] func_defs;
end


struct cg_astdesigner_ast
    noexport
    cgstr name;
    @cgvec[cg_astdesigner_struct_def*] node_defs;
    @cgvec[cg_astdesigner_fn_def*] func_defs;
    //TODO: more fns?
end


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// METHODS
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
method codegen cg_astdesigner_struct_def.ctor():
    this.name.s = 0;
    this.func_defs.ctor();
end

method codegen cg_astdesigner_struct_def.dtor():
    this.name:free();
    this.func_defs.dtor();
end

method codegen cg_astdesigner_fn_def.ctor():
    this.name.s = 0;
    this.code_in = cast(cgstrll*)0;
    this.code_out = cast(cgstrll*)0;
end
method codegen cg_astdesigner_fn_def.dtor():
    this.name.free();
end



method codegen cg_astdesigner_ast.ctor():
    this.name.s = 0;
    this.node_defs.ctor();
    this.func_defs.ctor();
end

method codegen cg_astdesigner_ast.dtor():
    this.name:free();
    this.node_defs.dtor();
    this.func_defs.dtor();
end


/*

@cgrdparser[
    cg_ast_designer
    [
        cg_astdesigner_ast ast_spec
    ]
    head[
        this.ast_spec.ctor();
        
        
        do parse_node_defs
        do parse_node_methods
        finish
    ]
    parse_node_defs[
        if(tok_not_null)
            ident[
                
                else
                    finish
            ]
        end
    ]
    parse_node_def[
    
    ]
    parse_node_methods[
        
    ]
    parse_node_method[
        
    ]
    finish[
        //TODO
        emitq ";"
        finish
    ]
]
*/



