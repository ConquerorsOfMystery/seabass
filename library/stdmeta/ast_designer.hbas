

#guard compiletime_ast_designer_lowlevel_DMHSW

#include <stdmeta/wksht.hbas>
#include <stdmeta/cgrdparse.hbas>



/*
    PLAN- THE AST DESIGNER
    
    Create a set of structs, possibly with circular dependency graphs (i.e. A->B->A) that
    represents your language, then write functions and methods that act on AST nodes.
    
    HOW DO I REPRESENT CIRCULAR DEPENDENCIES FOR STRUCTS IN MY LANGUAGE?
    
    1. all references to other nodes are turned into byte*. We can then turn all .member accesses
    into (  :member_reader()[0]). This is not completely bulletproof, though, and honestly it seems
    like it creates more problems than it solves...
    
    2. Define structs while you're defining structs. This is all compiletime CBAS, which means
    we don't need to go through the toc translator... so we *could* create circular dependencies
    as long as we only have pointer members. Not a big deal, right?
    
    3. We could constrict AST interaction within our AST manipulation code so that all AST interactions
    can easily be parsed, and then trick 1 can be applied. This is my best idea. Fundamentally, all
    AST interactions are inevitably member reads or writes (member access)... so... what's wrong?
    
    @cg_astdsgn_access_member [parent_expr] name
    
    which will turn into
    
    ((parent_expr):__name__()[0])
    
    This is a "low level interface" upon which I will design later implementations... it solves a problem
    that higher level tools need solved in order to function.
    
    HOW DO I GENERATE AST MANIPULATION CODE?
    
    Well, I figure much like cgrdparser, it's basically just CBAS with some macros, minor new language constructs, and syntax sugars.
    
    These manipulation functions are then written as members of the nodes.
    
    Setters and getters need to be written for every single one of a node's members, including
    vector member accesses.
    
    Code to manipulate AST nodes should be written in a DSL specifically designed for manipulating
    AST nodes. It should generally be CBAS, but with special statements for manipulating AST
    state (this makes writing the DSL easier).
    
    
*/



struct cg_astdesigner_struct_def
    noexport
    cgstr name;
    cgstrll* contents_in //before name mangling
    cgstrll* contents_out //after name mangling
    @cgvec[cgstrll*] func_defs;
end

struct cg_astdesigner_ast
    noexport
    cgstr name;
    @cgvec[cg_astdesigner_struct_def*] node_defs;
    @cgvec[cgstrll*] func_defs;
    //TODO: more fns?
end

method codegen cg_astdesigner_struct_def.ctor():
    this.name.s = 0;
    this.func_defs.ctor();
end

method codegen cg_astdesigner_struct_def.dtor():
    this.name:free();
    this.func_defs.dtor();
end

method codegen cg_astdesigner_ast.ctor():
    this.name.s = 0;
    this.node_defs.ctor();
    this.func_defs.ctor();
end

method codegen cg_astdesigner_ast.dtor():
    this.name:free();
    this.node_defs.dtor();
    this.func_defs.dtor();
end

